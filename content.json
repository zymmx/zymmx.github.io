{"meta":{"title":"木木夕","subtitle":null,"description":"如梦江湖 如戏人生","author":"木木夕","url":"https://zymmx.github.io"},"pages":[{"title":"404","date":"2018-11-21T06:39:09.000Z","updated":"2018-11-21T06:39:09.237Z","comments":true,"path":"404/index.html","permalink":"https://zymmx.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-21T06:38:53.000Z","updated":"2018-11-21T06:38:53.349Z","comments":true,"path":"search/index.html","permalink":"https://zymmx.github.io/search/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-21T15:03:42.000Z","updated":"2018-11-23T10:20:35.233Z","comments":true,"path":"about/index.html","permalink":"https://zymmx.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-21T08:14:18.642Z","updated":"2018-11-21T08:14:18.642Z","comments":true,"path":"tags/index.html","permalink":"https://zymmx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-21T15:00:49.764Z","updated":"2018-11-21T08:14:18.642Z","comments":true,"path":"categories/index.html","permalink":"https://zymmx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mybatis详解","slug":"mybatis","date":"2018-12-04T15:01:58.044Z","updated":"2018-12-04T15:01:58.044Z","comments":true,"path":"2018/12/04/mybatis/","link":"","permalink":"https://zymmx.github.io/2018/12/04/mybatis/","excerpt":"","text":"[TOC] mybatis01-入门-根据id查询数据一、什么是MyBatis（SQL Mapping Framework） MyBatis是对JDBC的封装， 将SQL语句放在了映射文件中， 并且能够自动的将输入参数映射到SQL语句的动态参数上 能够将SQL语句执行的结果集自动的映射成Java对象 底层原理： 利用dom4j对xml映射文件进行解析，利用java的反射机制以及动态代理模式生成动态的java类和代理对象，实现对jdbc的封装 MyBatis的核心要素： 1、映射文件（相当于原来的dao类，每个子节点相当于dao中的一个方法） 2、配置文件（配置数据库连接信息、事务和映射文件） 二、MyBatis入门示例 1、java项目：引入jar包 mybatis.jar包 jdbc包 log4j包 junit包 2、maven项目：jar形式，pom.xml 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、创建数据库表 执行 blog.sql（先创建库再执行） 4、创建实体类pojo Blog.java 12345678public class Blog &#123; private Integer id; private String title; private Integer authorId; private String state; private Boolean featured; private String style;&#125; 5、创建配置文件 5.1、log4j.properties日志文件 5.2、db.properties数据库 5.3、mybatis-config.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"db.properties\"&gt;&lt;/properties&gt; &lt;!-- 定义类型别名 --&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=\"name.yaohuan.mybatis.pojo.Blog\" alias=\"Blog\"/&gt; --&gt; &lt;package name=\"name.yaohuan.mybatis.pojo\"/&gt; &lt;/typeAliases&gt; &lt;!-- 定义数据源 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 定义映射文件 --&gt; &lt;mappers&gt; &lt;!-- &lt;mapper resource=\"name/yaohuan/mybatis/dao/BlogMapper.xml\"/&gt; --&gt; &lt;package name=\"name.yaohuan.mybatis.dao\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 说明： 数据库参数配置 类型别名：也可以批量定义别名 数据库环境配置，包含事务管理和数据库连接池配置 包含映射文件列表：也可以批量定义映射文件 注意：此种方法要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下； 5.4、BlogMapper.xml namespace对应接口的名字 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;name.yaohuan.mybatis.dao.BlogMapper&quot; &gt; &lt;/mapper&gt; 说明： mapper：namespace属性定义完全名，相当于类的全名(包名+类名) select：id属性定义了一个名为“selectBlog”的映射语句 使用 namespace + id 调用映射语句 6、在映射文件中编写SQL 1234&lt;!-- statment --&gt; &lt;select id=&quot;selectBlogById&quot; parameterType=&quot;int&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM blog WHERE id = #&#123;id&#125; &lt;/select&gt; 7、创建接口类和接口方法 123456package name.yaohuan.mybatis.dao;import java.util.List;import name.yaohuan.mybatis.pojo.Blog;public interface BlogMapper &#123; Blog selectBlogById(Integer id);&#125; 8、写工具类MyBatisUtil.java 1234567891011121314151617181920212223242526package name.yaohuan.mybatis.utils;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class MyBatisUtil &#123; private static SqlSessionFactory sqlSessionFactory = null; static&#123; try &#123; InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private MyBatisUtil()&#123;&#125; public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 9、单元测试 123456789101112131415161718package name.yaohuan.mybatis.dao;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import name.yaohuan.mybatis.pojo.Blog;import name.yaohuan.mybatis.utils.MyBatisUtil;public class BlogMapperTest &#123; @Test public void testSelectBlogById()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); Blog blog = blogDao.selectBlogById(1); session.close(); System.out.println(blog); &#125;&#125; 也可以不创建Mapper接口 12345678@Testpublic void testSelectBlogNoInterface() &#123; SqlSession session = MyBatisUtil.getSqlSession(); Blog blog = (Blog) session.selectOne( \"name.yaohuan.mybatis.dao.BlogMapper.selectBlogById\", 1); session.close(); System.out.println(blog);&#125; 补充： 02-数据库表的列名和实体类的属性名不一致的情况一、方案一 sql语句中定义别名 1234567891011&lt;!-- 使用别名处理列名不一致 --&gt; &lt;select id=\"selectBlogById\" parameterType=\"int\" resultType=\"Blog\"&gt; SELECT id, title, author_id AS authorId, state, featured, style FROM blog WHERE id = #&#123;id&#125; &lt;/select&gt; 二、方案二 使用resultMap 在resultMap中至少要定义一个主键列，使用定义其他列， cloumn表示表中的列名，property表示实体类中的字段 jdbcType是可选的参数，mybatis可以自动识别，可以省略 mapper： 1234&lt;resultMap type=&quot;Blog&quot; id=&quot;blogResultMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;author_id&quot; property=&quot;authorId&quot; /&gt; &lt;/resultMap&gt; 12345&lt;!-- 使用resultMap处理列名不一致 --&gt; &lt;select id=&quot;selectBlogById2&quot; parameterType=&quot;int&quot; resultMap=&quot;blogResultMap&quot;&gt; SELECT * FROM blog WHERE id = #&#123;id&#125; &lt;/select&gt; 接口： 1Blog selectBlogById2(Integer id); 测试用例： 12345678910@Test public void testSelectBlogById()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); Blog blog = blogDao.selectBlogById2(1); session.close(); System.out.println(blog); &#125; 03-模糊查询和排序-# 和 $一、模糊查询 需求：根据博客的名字查询博客列表（模糊查询） 方式一：使用#传参 mapper： 注意：参数占位符名称任意 123&lt;select id=&quot;selectBlogByTitle&quot; parameterType=&quot;string&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog where title like #&#123;title&#125; &lt;/select&gt; 接口： 1List&lt;Blog&gt; selectBlogByTitle(String title); 测试： 123456789101112@Test public void testSelectBlogByTitle() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogMapper.selectBlogByTitle(&quot;%o%&quot;); session.close(); System.out.println(blogList); &#125; 方式二：使用$传参 mapper： 注意：当时用$传参时，如果参数是单值类型（简单类型），并且只有一个参数， 那么参数必须使用 value 占位，并且如果参数是字符串，要使用引号： 123&lt;select id=&quot;selectBlogByTitle2&quot; parameterType=&quot;string&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog where title like &apos;%$&#123;value&#125;%&apos; &lt;/select&gt; 接口： 1List&lt;Blog&gt; selectBlogByTitle2(String title); 测试： 12345678910111213@Test public void testSelectBlogByTitle2() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); //List&lt;Blog&gt; blogList = blogMapper.selectBlogByTitle2(&quot;%o%&quot;); List&lt;Blog&gt; blogList = blogMapper.selectBlogByTitle2(&quot;o&quot;); session.close(); System.out.println(blogList); &#125; 比较#和$的区别： #是占位符？，$是字符串拼接。因此使用$的时候，如果参数是字符串类型，那么要使用引号 尽量使用# 而不是 $ 当参数表示表名或列名的时候，只能使用 $ 不区分大小写的查询： 123&lt;select id=&quot;selectBlogByTitle2&quot; parameterType=&quot;string&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog where lower(title) like lower(&apos;%$&#123;value&#125;%&apos;) &lt;/select&gt; 二、排序 需求：按照某一列排序 注意： 1、如果使用#，那么sql不会报错，但是排序功能不好使；所以应该使用$ 2、中文排序，需要使用mysql的转换函数 CONVERT mapper 1234&lt;select id=&quot;selectBlogBySort&quot; parameterType=&quot;string&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog order by CONVERT($&#123;value&#125; USING gbk) &lt;!-- select * from blog order by $&#123;value&#125; --&gt; &lt;/select&gt; 接口 1List&lt;Blog&gt; selectBlogBySort(String column); 测试 12345678910111213@Test public void testSelectBlogBySort() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogMapper.selectBlogBySort(&quot;title&quot;); /*List&lt;Blog&gt; blogList = blogMapper.selectBlogBySort(&quot;CONVERT(title USING gbk)&quot;);*/ session.close(); System.out.println(blogList); &#125; 04-分页-多参数传递需求：查询分页数据 一、方法一：使用索引 按照参数的顺序，从0开始 3.2版本：#{0}, #{1} 3.4版本：#{arg0}, #{arg1} 或 #{param1}, #{param2} mapper： 123&lt;select id=&quot;selectBlogByPage&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog limit #&#123;0&#125;, #&#123;1&#125; &lt;/select&gt; 接口： 参数名任意 1List&lt;Blog&gt; selectBlogByPage(int offset, int pagesize); 测试： 123456789101112@Test public void testSelectBlogByPage() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogMapper.selectBlogByPage(2, 2); session.close(); System.out.println(blogList); &#125; 二、方法二：使用注解 mapper 123&lt;select id=&quot;selectBlogByPage2&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog limit #&#123;offset&#125;, #&#123;pagesize&#125; &lt;/select&gt; 接口：注解的value值要和mapper的占位参数一致 123List&lt;Blog&gt; selectBlogByPage2( @Param(value=&quot;offset&quot;) int offset, @Param(value=&quot;pagesize&quot;) int pagesize); 三、方法三：使用map mapper中的参数占位符要和测试中的map的key 一 一对应 mapper 123&lt;select id=&quot;selectBlogByPage3&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog limit #&#123;offset&#125;, #&#123;pagesize&#125; &lt;/select&gt; 接口 1List&lt;Blog&gt; selectBlogByPage3(Map&lt;String, Object&gt; map); 测试： 12345678910111213141516@Test public void testSelectBlogByPage3() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"offset\", 2); map.put(\"pagesize\", 2); List&lt;Blog&gt; blogList = blogMapper.selectBlogByPage3(map); session.close(); System.out.println(blogList); &#125; 05-插入-获取刚刚插入的id（自增id）一、插入记录 需求：新增一个博客记录 mapper 1234567891011121314151617&lt;insert id=&quot;insertBlog&quot; parameterType=&quot;Blog&quot;&gt; INSERT INTO `blog` ( `title`, `author_id`, `state`, `featured`, `style` ) VALUES ( #&#123;title&#125;, #&#123;authorId&#125;, #&#123;state&#125;, #&#123;featured&#125;, #&#123;style&#125; ) &lt;/insert&gt; 接口： 1int insertBlog(Blog blog); 测试： 1234567891011121314151617181920@Testpublic void testInsertBlog() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setTitle(\"我的blog\"); blog.setState(\"ACTIVE\"); blog.setStyle(\"pink\"); blog.setFeatured(true); blog.setAuthorId(1); int count = blogMapper.insertBlog(blog); session.commit(); session.close(); System.out.println(blog);//看看是否有id值（没值） System.out.println(\"插入了\" + count + \"条记录\");&#125; 二、获取自增id 方式一：在mapper中配置 insert节点的属性 useGeneratedKeys=”true” keyProperty=”id” mapper 1234567891011121314151617&lt;insert id=\"insertBlog\" parameterType=\"Blog\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; INSERT INTO `blog` ( `title`, `author_id`, `state`, `featured`, `style` ) VALUES ( #&#123;title&#125;, #&#123;authorId&#125;, #&#123;state&#125;, #&#123;featured&#125;, #&#123;style&#125; ) &lt;/insert&gt; 方式二：在全局配置文件中配置 settings选项 123&lt;settings&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot; /&gt; &lt;/settings&gt; 并且在mapper的insert节点配置属性 keyProperty=”id” 方式三：适用于没有自增主键的数据库（或者mysql中没有使用主键自增策略） mysql版本： 1234567891011121314151617181920&lt;insert id=\"insertBlogMysql\" parameterType=\"Blog\"&gt; &lt;selectKey resultType=\"java.lang.Integer\" order=\"AFTER\" keyProperty=\"id\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO `blog` ( `title`, `author_id`, `state`, `featured`, `style` ) VALUES ( #&#123;title&#125;, #&#123;authorId&#125;, #&#123;state&#125;, #&#123;featured&#125;, #&#123;style&#125; ) &lt;/insert&gt; oracle版本 1234567891011121314151617181920&lt;insert id=\"insertBlogOracle\" parameterType=\"Blog\"&gt; &lt;selectKey resultType=\"java.lang.Integer\" order=\"BEFORE\" keyProperty=\"id\"&gt; select seq.nextval as id from dual &lt;/selectKey&gt; INSERT INTO `blog` ( `title`, `author_id`, `state`, `featured`, `style` ) VALUES ( #&#123;title&#125;, #&#123;authorId&#125;, #&#123;state&#125;, #&#123;featured&#125;, #&#123;style&#125; ) &lt;/insert&gt; 06-修改mapper： 1234567891011&lt;update id=&quot;updateBlog&quot; parameterType=&quot;Blog&quot;&gt; UPDATE blog SET title = #&#123;title&#125;, author_id = #&#123;authorId&#125;, state = #&#123;state&#125;, featured = #&#123;featured&#125;, style = #&#123;style&#125; WHERE id = #&#123;id&#125; ; &lt;/update&gt; 接口： 1int updateBlog(Blog blog); 测试用例： 123456789101112131415161718192021@Testpublic void testUpdateBlog()&#123; SqlSession session = MyBatisUtil.getSqlSession(); Blog blog = new Blog(); blog.setId(27); blog.setAuthorId(2); blog.setState(\"NOT ACTIVE\"); blog.setFeatured(false); blog.setStyle(\"blue\"); blog.setTitle(\"an's blog\"); BlogMapper blogDao = session.getMapper(BlogMapper.class); int count = blogDao.updateBlog(blog); session.commit(); session.close(); System.out.println(\"修改了\" + count + \"条记录\");&#125; 注意：修改时如果不想修改所有字段，那么可以用如下的方式 方法一、先查询记录，再在查询出来的记录上修改 测试用例： 123456789101112131415161718192021@Test public void testUpdateBlog2()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); //查询 Blog blog = blogDao.selectBlogById(27); //修改 blog.setId(27); blog.setAuthorId(2); blog.setTitle(\"new blog\"); int count = blogDao.updateBlog(blog); session.commit(); session.close(); System.out.println(\"修改了\" + count + \"条记录\"); &#125; 方法二、动态SQL 参考后面的动态SQL 07-删除一、删除 注意：关联表级联删除的问题会报告如下错误 解决方案1：先删除子记录，再删除父记录 解决方案2：在数据库的外键中设置级联删除 mapper： 123&lt;delete id=&quot;deleteBlogById&quot; parameterType=&quot;int&quot;&gt; DELETE FROM blog WHERE id = #&#123;id&#125; &lt;/delete&gt; 接口： 1int deleteBlogById(Integer id); 测试用例： 1234567891011121314@Test public void testDeleteBlogById()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); int count = blogDao.deleteBlogById(27); session.commit(); session.close(); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); &#125; 二、批量删除 参考后面的动态SQL 08-动态SQL-if 案例一 需求： 1、按博客的名字模糊查询已激活的博客 2、如果用户没有输入任何查询字符串，那么查询所有已激活的blog 分析： – 用户输入了查询字符串 SELECT * FROM blog WHERE state = ‘ACTIVE’ AND title LIKE ‘%a%’ – 用户没有输入查询字符串 SELECT * FROM blog WHERE state = ‘ACTIVE’ 注意： 1、参数类型如果是多值对象，如Blog类型，那么if语句中的test属性判断使用Blog的属性名 2、参数类型如果是简单类型，如String类型，那么if语句中的test属性判断使用value关键字 如果使用简单类型（string），那么test中无法判断 空字符串””（不要写value != ‘’ 判断不出来，有坑） 如果使用$ 那么 传值应该使用 ${value}， if中判断也应该使用 value 关键字 如果使用# 那么 传值应该使用 #{任意名}， if中判断还是使用 value 关键字 因此：最好使用对象传参 传递单值参数 mapper： 1234567&lt;select id=&quot;selectActiveBlogByTitle&quot; parameterType=&quot;string&quot; resultMap=&quot;blogResultMap&quot;&gt; SELECT * FROM blog WHERE state = &apos;ACTIVE&apos; &lt;if test=&quot;value != null and value != &apos;&apos;&quot;&gt; AND title LIKE &apos;%$&#123;value&#125;%&apos; &lt;/if&gt; &lt;/select&gt; 接口： 1List&lt;Blog&gt; selectActiveBlogByTitle(String title); 测试用例： 1234567891011121314@Test public void testSelectActiveBlogByTitle()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); //List&lt;Blog&gt; blogList = blogDao.selectActiveBlogByTitle(&quot;o&quot;); //List&lt;Blog&gt; blogList = blogDao.selectActiveBlogByTitle(&quot;&quot;); List&lt;Blog&gt; blogList = blogDao.selectActiveBlogByTitle(null); session.close(); System.out.println(blogList); &#125; 案例二 需求： 1、查询已激活的，并且根据blog的名字和是否推荐来查询 2、如果用户没有输入任何查询条件，那么查询所有已激活的blog 分析： – 用户输入了查询条件 SELECT * FROM blog WHERE state = ‘ACTIVE’ AND title LIKE ‘%a%’ AND featured = TRUE – 用户没有输入查询条件 SELECT * FROM blog WHERE state = ‘ACTIVE’ 注意：要修改pojo中Blog的featured的数据类型是Boolean 方案：传递多值对象参数 mapper： 映射文件中可以使用参数Blog中的属性的名称 12345678910&lt;select id=&quot;selectActiveBlogByTitleAndFeatured&quot; parameterType=&quot;Blog&quot; resultMap=&quot;blogResultMap&quot;&gt; SELECT * FROM blog WHERE state = &apos;ACTIVE&apos; &lt;if test=&quot;title != null and title != &apos;&apos;&quot;&gt; AND title LIKE &apos;%$&#123;title&#125;%&apos; &lt;/if&gt; &lt;if test=&quot;featured != null&quot;&gt; AND featured = #&#123;featured&#125; &lt;/if&gt;&lt;/select&gt; 接口： 1List&lt;Blog&gt; selectActiveBlogByTitleAndFeatured(Blog blog); 测试用例： 12345678910111213141516@Test public void testSelectActiveBlogByTitleAndFeatured()&#123; SqlSession session = MyBatisUtil.getSqlSession(); Blog blog = new Blog(); blog.setTitle(&quot;树&quot;); blog.setFeatured(true); BlogMapper blogDao = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogDao.selectActiveBlogByTitleAndFeatured(blog); session.close(); System.out.println(blogList); &#125; 补充：忽略大小写的查询，使用LOWER或UPPER 1AND LOWER(title) LIKE LOWER(&apos;%$&#123;title&#125;%&apos;) 09-动态SQL-choose、when、otherwisechoose：在when和otherwise中选择 when：必须的，一个或多个 otherwise：可选的，一个或零个 需求： 1、查询已激活的 2、如果用户输入了blog的查询关键字， 3、则根据关键字查询，否则根据blog的风格样式查询， 4、否则给用户显示推荐的blog 分析： 2、3、4条件互斥 方案： mapper： 123456789101112131415&lt;select id=\"selectActiveBlogByTitleOrStyle\" parameterType=\"Blog\" resultMap=\"blogResultMap\"&gt; SELECT * FROM blog WHERE state = 'ACTIVE' &lt;choose&gt; &lt;when test=\"title != null and title != ''\"&gt; AND LOWER(title) LIKE LOWER('%$&#123;title&#125;%') &lt;/when&gt; &lt;when test=\"style != null\"&gt; AND style = #&#123;style&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = true &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; 接口： 1List&lt;Blog&gt; selectActiveBlogByTitleOrStyle(Blog blog); 测试用例： 12345678910111213141516@Test public void testSelectActiveBlogByTitleOrStyle()&#123; SqlSession session = MyBatisUtil.getSqlSession(); Blog blog = new Blog(); //blog.setTitle(\"O\"); //blog.setStyle(\"red\"); BlogMapper blogDao = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogDao.selectActiveBlogByTitleOrStyle(blog); session.close(); System.out.println(blogList); &#125; 10-动态SQL-where需求： 多条件查询：状态、标题、是否推荐 会自动去掉查询条件中多余的第一个逻辑符号，如 and、or mapper： 1234567891011121314&lt;select id=\"selectBlog\" parameterType=\"Blog\" resultMap=\"blogResultMap\"&gt; SELECT * FROM blog &lt;where&gt; &lt;if test=\"state != null and state != ''\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null and title != ''\"&gt; AND LOWER(title) LIKE LOWER('%$&#123;title&#125;%') &lt;/if&gt; &lt;if test=\"featured != null\"&gt; AND featured = #&#123;featured&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 接口： 1List&lt;Blog&gt; selectBlog(Blog blog); 测试用例： 1234567891011121314151617@Test public void testSelectBlog()&#123; SqlSession session = MyBatisUtil.getSqlSession(); Blog blog = new Blog(); blog.setState(&quot;ACTIVE&quot;); blog.setTitle(&quot;O&quot;); blog.setFeatured(false); BlogMapper blogDao = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogDao.selectBlog(blog); session.close(); System.out.println(blogList); &#125; 11-动态SQL-set需求： 按需修改：修改指定的列，未指定的不修改 会自动去掉update语句的set子句中多余的最后一个逗号 mapper： 123456789101112131415161718192021&lt;update id=\"updateBlogIfNecessary\" parameterType=\"Blog\"&gt; UPDATE blog &lt;set&gt; &lt;if test=\"title != null and title != ''\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"authorId != null\"&gt; author_id = #&#123;authorId&#125;, &lt;/if&gt; &lt;if test=\"state != null and state != ''\"&gt; state = #&#123;state&#125;, &lt;/if&gt; &lt;if test=\"featured != null\"&gt; featured = #&#123;featured&#125;, &lt;/if&gt; &lt;if test=\"style != null and style != ''\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;/set&gt; WHERE id = #&#123;id&#125; &lt;/update&gt; 接口： 1int updateBlogIfNecessary(Blog blog); 测试用例： 1234567891011121314151617@Test public void testUpdateBlogIfNecessary()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(3); blog.setTitle(\"new title\"); int count = blogDao.updateBlogIfNecessary(blog); session.commit(); session.close(); System.out.println(\"修改了\" + count + \"条记录\"); &#125; 12-动态SQL-trimtrim可以实现set和where的功能 一、trim实现where的功能 mapper： 1234567891011121314&lt;select id=\"selectBlogTrim\" parameterType=\"Blog\" resultMap=\"blogResultMap\"&gt; SELECT * FROM blog &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND | OR\"&gt; &lt;if test=\"state != null and state != ''\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null and title != ''\"&gt; AND LOWER(title) LIKE LOWER('%$&#123;title&#125;%') &lt;/if&gt; &lt;if test=\"featured != null\"&gt; AND featured = #&#123;featured&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; 接口： 1List&lt;Blog&gt; selectBlogTrim(Blog blog); 测试用例： 1234567891011121314151617@Test public void testSelectBlogTrim()&#123; SqlSession session = MyBatisUtil.getSqlSession(); Blog blog = new Blog(); blog.setState(\"ACTIVE\"); blog.setTitle(\"O\"); blog.setFeatured(false); BlogMapper blogDao = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogDao.selectBlogTrim(blog); session.close(); System.out.println(blogList); &#125; 二、trim实现set的功能 mapper： 123456789101112131415161718192021&lt;update id=\"updateBlogIfNecessaryTrim\" parameterType=\"Blog\"&gt; UPDATE blog &lt;trim prefix=\"SET\" suffixOverrides=\",\"&gt; &lt;if test=\"title != null and title != ''\"&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=\"authorId != null\"&gt; author_id = #&#123;authorId&#125;, &lt;/if&gt; &lt;if test=\"state != null and state != ''\"&gt; state = #&#123;state&#125;, &lt;/if&gt; &lt;if test=\"featured != null\"&gt; featured = #&#123;featured&#125;, &lt;/if&gt; &lt;if test=\"style != null and style != ''\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;/trim&gt; WHERE id = #&#123;id&#125; &lt;/update&gt; 接口： 1int updateBlogIfNecessaryTrim(Blog blog); 测试用例： 1234567891011121314151617@Testpublic void testUpdateBlogIfNecessaryTrim()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(3); blog.setTitle(&quot;new title&quot;); int count = blogDao.updateBlogIfNecessaryTrim(blog); session.commit(); session.close(); System.out.println(&quot;修改了&quot; + count + &quot;条记录&quot;);&#125; 13-动态SQL-foreach需求：实现批量删除 向sql传递数组或List时，mybatis使用foreach解析数组里的参数并拼接到SQL中。 mapper： 123456&lt;delete id=&quot;deleteBlogList&quot; parameterType=&quot;list&quot;&gt; DELETE FROM blog WHERE id IN &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/delete&gt; 接口： 1int deleteBlogList(List&lt;Integer&gt; idList); 测试用例： 1234567891011121314151617/** * 批量删除 */ @Test public void testDeleteBlogList()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); List&lt;Integer&gt; idList = Arrays.asList(10,20,30); int count = blogDao.deleteBlogList(idList); session.commit(); session.close(); System.out.println(\"删除了\" + count + \"条记录\"); &#125; 14-动态SQL-SQL片段Mybatis提供了SQL片段的功能，可以提高SQL的可重用性 定义片段： 123456789&lt;!-- 定义列名片段 --&gt;&lt;sql id=\"columnBase\"&gt; id, title, author_id AS authorId, state, featured, style&lt;/sql&gt; 使用片段： 12345&lt;select id=&quot;selectBlogById&quot; parameterType=&quot;int&quot; resultType=&quot;Blog&quot;&gt; SELECT &lt;include refid=&quot;columnBase&quot;&gt;&lt;/include&gt; FROM blog WHERE id = #&#123;id&#125; &lt;/select&gt; 15-性能-一级缓存一级缓存就是session级别的缓存，一级缓存默认存在 一、测试一： 下面的测试说明：两次查询，第一次查询结果从数据库查询，缓存到sqlsession缓存区域，第二次查询直接返回，不查询数据库。 12345678910111213141516/** * 一级缓存测试1 */ @Test public void testCacheLevelOne1()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); //第一次查询执行sql语句 Blog blog1 = blogDao.selectBlogById(1); System.out.println(\"查询结果\"); //第二次查询不执行sql语句，直接从缓存中读取数据 Blog blog2 = blogDao.selectBlogById(1); System.out.println(\"查询结果\"); session.close(); &#125; 二、测试二： 在第一个测试用例的基础上增加中间黄色的部分 下面的测试说明：如果两次查询之间，有增加、删除、修改操作并其提交，sqlsession缓存区域会自动清空。 1234567891011121314151617181920212223/** * 一级缓存测试2 */ @Test public void testCacheLevelOne2()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); //第一次查询执行sql语句 Blog blog1 = blogDao.selectBlogById(1); System.out.println(\"查询结果\"); //如果有insert、update和delete，则会清空缓存空间 blog1.setFeatured(true); blogDao.updateBlog(blog1); System.out.println(\"更新\"); //第二次查询重新执行sql语句 Blog blog2 = blogDao.selectBlogById(1); System.out.println(\"查询结果\"); session.commit(); session.close(); &#125; 16-性能-二级缓存一、测试： 跨seesion范围，默认情况下，不配置二级缓存，会执行两次数据库的sql查询 注意：这个例子中创建了两个session对象： 1234567891011121314151617181920/** * 二级缓存测试 */@Testpublic void testCacheLevelTwo() &#123; //第一次查询执行sql语句 SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogDao1 = session1.getMapper(BlogMapper.class); Blog blog1 = blogDao1.selectBlogById(1); System.out.println(\"查询结果\"); session1.close(); //不开启二级缓存时：第二次查询 执行sql语句 SqlSession session2 = MyBatisUtil.getSqlSession(); BlogMapper blogDao2 = session2.getMapper(BlogMapper.class); Blog blog2 = blogDao2.selectBlogById(1); System.out.println(\"查询结果\"); session2.close();&#125; 二、启用二级缓存： 1、在对应的表的mapper映射文件中添加一行 123&lt;mapper namespace=&quot;name.yaohuan.mybatis.dao.BlogMapper&quot;&gt; &lt;!-- 开启二级缓存 --&gt; &lt;cache /&gt; 2、对应的实体类必须是可以序列化的 12public class Blog implements Serializable&#123; private static final long serialVersionUID = 1L; 重新执行上面的测试用例 一旦看到Cache Hit Ratio 命中率，说明二级缓存开启成功，查到次数/查询次数=0.0 第二次查询，直接从缓存读取数据，命中率： 1/2=0.5 这个简单语句的效果如下： 映射语句文件中的所有select语句将会被缓存。 和一级缓存一样，所有insert，update和delete语句会刷新缓存。 例如：在第一次session关闭前加入update语句会清空缓存 1234blog1.setFeatured(true); blogDao1.updateBlog(blog1); System.out.println(&quot;更新&quot;); session1.commit(); 对于映射文件的select： useCache属性 将其设置为true，将会导致本条语句的结果被缓存。默认值：true。 如果设置成false，可以阻止二级缓存的产生，但不能阻止一级缓存的产生。 对于映射文件的select、insert、update、delete： flushCache属性 将其设置为true，无论语句什么时候被调用，都会导致缓存被清空。 可以清空一级缓存和二级缓存 其他： 配置属性： 所有的这些属性都可以通过缓存元素的属性来修改。比如： 这个更高级的配置创建了一个FIFO缓存，并每隔60秒刷新，存数结果对象或列表的512个引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改它们会导致冲突。 可用的收回策略有： . LRU – 最近最少使用的：移除最长时间不被使用的对象。 . FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 . SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 . WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是LRU。 flushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。 size（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是1024。 readOnly（只读）属性可以被设置为true或false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。 全局配置： 注意：cacheEnabled 默认就是开启的，设置为false则全局范围内关闭二级缓存 12345&lt;!-- 全局设置 --&gt; &lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt; ...... &lt;/settings&gt; 三、应用场景： 对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。 注意：在使用二级缓存的时候，要设置一下刷新间隔（cache标签中有一个flashInterval属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，单位为毫秒 四、局限性： Mybatis二级缓存对细粒度的数据，缓存实现不好。 场景：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。 解决此类问题，需要在业务层根据需要对数据有针对性的缓存。 比如可以对经常变化的 数据操作单独放到另一个namespace的mapper中。 17-性能-整合ehcache 一、什么是ehcache Mybatis本身是一个持久层框架，它不是专门的缓存框架，所以它对缓存的实现不够好，不能支持分布式。 Ehcache是一个分布式的缓存框架。 二、整合思路 Cache是一个接口，它的默认实现是mybatis的PerpetualCache。如果想整合mybatis的二级缓存，那么实现Cache接口即可。 三、整合步骤 1、添加jar包： 2、设置映射文件中cache标签的type值为ehcache的实现类： 123&lt;!-- 第三方二级缓存框架 --&gt; &lt;!-- type: 二级缓存的实现类，默认实现类是 org.apache.ibatis.cache.implPerpetualCache--&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; /&gt; 3、添加ehcache的配置文件： 在配置文件目录下创建ehcache.xml 12345678910111213141516171819202122232425262728293031&lt;!-- 缓存数据要存放的磁盘地址 --&gt;&lt;diskStore path=&quot;D:\\ehcache&quot; /&gt;&lt;!-- diskStore：指定数据在磁盘中的存储位置。 defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略 以下属性是必须的： maxElementsInMemory - 在内存中缓存的element的最大数目 maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大 eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断 overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 以下属性是可选的： timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除， 默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB - 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区. diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。 diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作 memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt;&lt;defaultCache maxElementsInMemory=&quot;1000&quot;maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;false&quot;timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot;diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;&lt;/defaultCache&gt; 4、测试： 参考上一节的测试方式 18-高级结果映射-嵌套查询-关联映射项目：mybatis02relation 把pojo拷贝过来，重新创建映射文件 需求：查询博客信息，同时查询作者信息：Blog和Author是一对一的关系 注意：如果有相互引用，则打印输出的时候会出现栈内存溢出的异常，可以将一方的关联配置配置到返回值是 resultType 的 statement 中 关联映射（适用于一对一和多对一） pojo：在Blog类中设计author属性，用来替换authorId 1234public class Blog &#123; /*private Integer authorId;*/ private Author author;&#125; pojo：Author 1234567891011package name.yaohuan.mybatis.pojo;public class Author &#123; private Integer id; private String username; private String password; private String email; private String bio; private String favouriteSection; private String nickname; private String realname;&#125; blog的mapper： 说明： 1、property对应实体类中的属性 2、column对应数据库中的外键字段 3、javaType表示实体类中属性的类型，在这里不是必须的属性 4、select表示通过column字段进一步查询需要的sql语句，column的值作为参数传递给这个sql语句 123456789&lt;resultMap type=\"Blog\" id=\"blogResultMap\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"name.yaohuan.mybatis.dao.AuthorMapper.selectAuthorById\"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"selectBlogById\" parameterType=\"int\" resultMap=\"blogResultMap\"&gt; SELECT * FROM blog WHERE id = #&#123;id&#125; &lt;/select&gt; author的mapper： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"name.yaohuan.mybatis.dao.AuthorMapper\" &gt; &lt;resultMap type=\"Author\" id=\"authorResultMap\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"favourite_section\" property=\"favouriteSection\" jdbcType=\"VARCHAR\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectAuthorById\" parameterType=\"int\" resultMap=\"authorResultMap\"&gt; SELECT * FROM author WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; blog的接口： 1Blog selectBlogById(Integer id); author的接口： 1Author selectAuthorById(Integer id); 测试用例 1： 1234567891011121314public class BlogMapperTest &#123; @Test public void testSelectBlogById()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); Blog blog = blogDao.selectBlogById(2); session.close(); System.out.println(blog); &#125;&#125; 测试用例2： 查询Blog列表时，执行的sql语句是 1 + n ， 但是如果blog关联的author有重复的数据，那么回从一级缓存中查询。 123&lt;select id=&quot;selectBlogList&quot; resultMap=&quot;blogResultMap&quot;&gt; select * from blog &lt;/select&gt; 1List&lt;Blog&gt; selectBlogList(); 123456789101112@Test public void testSelectBlogList() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); List&lt;Blog&gt; blogList = blogDao.selectBlogList(); session.close(); System.out.println(blogList); &#125; 其他案例：post中的author 和 blog 12345678910&lt;resultMap type=&quot;Post&quot; id=&quot;postResultMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot; /&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;name.yaohuan.mybatis.dao.AuthorMapper.selectAuthorById&quot;&gt;&lt;/association&gt; &lt;association property=&quot;blog&quot; column=&quot;blog_id&quot; javaType=&quot;Blog&quot; select=&quot;name.yaohuan.mybatis.dao.BlogMapper.selectBlogById&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; 19-高级结果映射-嵌套查询-集合映射集合映射（适用于一对多和多对多） 需求：查询文章信息，同时查询这篇文章的评论列表 思考：执行sql语句的条数 pojo：Post 12345678910111213141516package name.yaohuan.mybatis.pojo;import java.util.Date;import java.util.List;public class Post &#123; private Integer id; private Author author; private Blog blog; private Date createOn; private String section; private String subject; private String draft; private String body; private Integer visit; /*private List&lt;Tag&gt; tagList;*///作业 private List&lt;Comment&gt; commentList;&#125; pojo：Comment 12345678package name.yaohuan.mybatis.pojo;import java.util.Date;public class Comment &#123; private Integer id; private String name; private String comment; private Date createOn;&#125; post的mapper： 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"name.yaohuan.mybatis.dao.PostMapper\" &gt; &lt;resultMap type=\"Post\" id=\"postResultMap\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"name.yaohuan.mybatis.dao.AuthorMapper.selectAuthorById\"&gt;&lt;/association&gt; &lt;association property=\"blog\" column=\"blog_id\" javaType=\"Blog\" select=\"name.yaohuan.mybatis.dao.BlogMapper.selectBlogById\"&gt;&lt;/association&gt; &lt;collection property=\"commentList\" column=\"id\" javaType=\"ArrayList\" ofType=\"Comment\" select=\"name.yaohuan.mybatis.dao.CommentMapper.selectCommentByPostId\" &gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 思考执行了几条sql --&gt; &lt;select id=\"selectPostById\" parameterType=\"int\" resultMap=\"postResultMap\"&gt; SELECT * FROM post WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 思考执行了几条sql --&gt; &lt;select id=\"selectPostList\" parameterType=\"int\" resultMap=\"postResultMap\"&gt; SELECT * FROM post &lt;/select&gt;&lt;/mapper&gt; comment的mapper： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"name.yaohuan.mybatis.dao.CommentMapper\" &gt; &lt;resultMap type=\"Comment\" id=\"commentResultMap\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\" /&gt; &lt;result column=\"create_on\" property=\"createOn\" jdbcType=\"DATE\" /&gt; &lt;/resultMap&gt; &lt;select id=\"selectCommentByPostId\" parameterType=\"int\" resultMap=\"commentResultMap\"&gt; SELECT * FROM comment WHERE post_id = #&#123;postId&#125; &lt;/select&gt;&lt;/mapper&gt; post的接口： 1234567package name.yaohuan.mybatis.dao;import java.util.List;import name.yaohuan.mybatis.pojo.Post;public interface PostMapper &#123; Post selectPostById(Integer id); List&lt;Post&gt; selectPostList();&#125; comment的接口： 123456package name.yaohuan.mybatis.dao;import java.util.List;import name.yaohuan.mybatis.pojo.Comment;public interface CommentMapper &#123; List&lt;Comment&gt; selectCommentByPostId(Integer postId);&#125; 测试用例： 12345678910111213141516171819202122232425@Test public void testSelectPostById()&#123; SqlSession session = MyBatisUtil.getSqlSession(); PostMapper postDao = session.getMapper(PostMapper.class); Post post = postDao.selectPostById(2); session.close(); System.out.println(post); &#125; @Test public void testSelectPostList()&#123; SqlSession session = MyBatisUtil.getSqlSession(); PostMapper postDao = session.getMapper(PostMapper.class); List&lt;Post&gt; postList = postDao.selectPostList(); session.close(); System.out.println(postList); &#125; 20-高级结果映射-嵌套结果上一节讲了嵌套查询，嵌套查询的方式很简单，但是对于大型数据集合和列表将不会表现很好。问题就是我们熟知的“N+1查询问题”。 概括地讲，N+1查询问题可以是这样引起的： 你执行了一个单独的SQL语句来获取结果列表（就是“+1”）。 对返回的每条记录，你执行了一个查询语句来为每个加载细节（就是“N”）。 这个问题会导致成百上千的SQL语句被执行。这通常不是期望的。 所以还有另外一种方法：嵌套结果 结果集映射： 方式一： 使用 association 映射嵌套的结果列 123456789101112131415&lt;!-- 嵌套结果 --&gt; &lt;resultMap type=\"Blog\" id=\"blogResultMapNested\"&gt; &lt;id column=\"blog_id\" property=\"id\"/&gt; &lt;result column=\"blog_title\" property=\"title\" /&gt; &lt;result column=\"blog_state\" property=\"state\" /&gt; &lt;result column=\"blog_featured\" property=\"featured\" /&gt; &lt;association property=\"author\" column=\"blog_author_id\" javaType=\"Author\"&gt; &lt;id column=\"author_id\" property=\"id\" /&gt; &lt;result column=\"author_username\" property=\"username\" /&gt; &lt;result column=\"author_password\" property=\"password\" /&gt; &lt;result column=\"author_email\" property=\"email\" /&gt; &lt;result column=\"author_bio\" property=\"bio\" /&gt; &lt;result column=\"author_favourite_section\" property=\"favouriteSection\" /&gt; &lt;/association&gt; &lt;/resultMap&gt; 查询语句： 注意： 1、要使用列的别名避免列名重复 2、使用关联查询（内连接、或外连接）将所有需要的列查询出来 123456789101112131415161718192021 &lt;!-- 关联查询 --&gt;&lt;select id=\"selectBlogListNested\" resultMap=\"blogResultMapNested\"&gt;SELECT b.id AS blog_id, b.title AS blog_title, b.author_id AS blog_author_id, b.state AS blog_state, b.featured AS blog_featured, b.style AS blog_style, a.id AS author_id, a.username AS author_username, a.password AS author_password, a.email AS author_email, a.bio AS author_bio, a.favourite_section AS author_favourite_section, a.nickname AS author_nickname, a.realname AS author_realname FROM blog b LEFT JOIN author a ON b.author_id = a.id&lt;/select&gt; 方式二： 使用继承，让结果集更灵活 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;resultMap type=&quot;Blog&quot; id=&quot;blogResultMap2&quot;&gt; &lt;id column=&quot;blog_id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;blog_title&quot; property=&quot;title&quot;/&gt; &lt;result column=&quot;blog_state&quot; property=&quot;state&quot;/&gt; &lt;result column=&quot;blog_featured&quot; property=&quot;featured&quot;/&gt; &lt;result column=&quot;blog_style&quot; property=&quot;style&quot;/&gt; &lt;/resultMap&gt; &lt;resultMap type=&quot;Blog&quot; id=&quot;blogResultMapNested2&quot; extends=&quot;blogResultMap2&quot;&gt; &lt;association column=&quot;blog_author_id&quot; property=&quot;author&quot; javaType=&quot;Author&quot;&gt; &lt;id column=&quot;author_id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;author_username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;author_password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;author_email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;author_bio&quot; property=&quot;bio&quot;/&gt; &lt;result column=&quot;author_favourite_section&quot; property=&quot;favouriteSection&quot;/&gt; &lt;result column=&quot;author_nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;author_realname&quot; property=&quot;realname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectBlogListNested&quot; resultMap=&quot;blogResultMapNested2&quot;&gt; SELECT b.id AS blog_id, b.title AS blog_title, b.author_id AS blog_author_id, b.state AS blog_state, b.featured AS blog_featured, b.style AS blog_style, a.id AS author_id, a.username AS author_username, a.password AS author_password, a.email AS author_email, a.bio AS author_bio, a.favourite_section AS author_favourite_section, a.nickname AS author_nickname, a.realname AS author_realname FROM blog b LEFT JOIN author a ON b.author_id = a.id &lt;/select&gt; 21-高级结果映射-构造方法映射pojo中创建构造方法： 1、注意：要使用Integer而不是int 123456public Blog(Integer id, String title) &#123; super(); this.id = id; this.title = title; System.out.println(&quot;构造方法。。。。。。。。。。。。。。&quot;); &#125; mapper中创建构造方法映射： 1234567&lt;!-- 构造方法映射 --&gt; &lt;resultMap type=&quot;Blog&quot; id=&quot;blogResultMapConstructor&quot;&gt; &lt;constructor&gt; &lt;idArg column=&quot;id&quot; javaType=&quot;int&quot; /&gt; &lt;arg column=&quot;title&quot; javaType=&quot;string&quot; /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; 使用构造方法的映射结果： 注意： 1、include中的内容包含：id, title, author_id, state, featured mybatis在做结果映射的时候会首先调用构造函数将id，和title映射到结果对象中， 然后调用 setXxx 方法 将state 和 featured 映射到结果对象中 如果需要映射 author 属性，则可以按照之前的方法 添加 节点做嵌套查询映射 1234&lt;select id=&quot;selectBlogConstructor&quot; parameterType=&quot;int&quot; resultMap=&quot;blogResultMapConstructor&quot;&gt; select &lt;include refid=&quot;columnWords&quot;&gt;&lt;/include&gt; from Blog where id = #&#123;id&#125; &lt;/select&gt; 接口： 1Blog selectBlogConstructor(Integer id); 测试： 123456789@Test public void testSelectBlogConstructor()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); Blog blog = blogDao.selectBlogConstructor(3); session.close(); System.out.println(blog); &#125; 22-高级结果映射-鉴别器类型鉴别器，帮助实现创建多态的对象，用于多态映射 示例： 一、类设计 1、交通工具类 12345678public abstract class Vehicle &#123; private Integer id; private String vin;//车辆识别代码Veterinary information network private Date year; private String make;//品牌：what make is it private String model;// private String color;&#125; 2、小汽车类 12public class Car extends Vehicle&#123; private Integer doorCount; 3、Suv类 123public class Suv extends Vehicle&#123; private Boolean allWheelDrive;//全轮驱动 awd&#125; 二、数据库设计 三、代码实现 配置文件： 注意： 1、一定要有鉴别器，测试才能通过 2、查询结果中一定要包含鉴别器列 12345678910111213141516171819&lt;resultMap type=\"Vehicle\" id=\"vehicleResultMap\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;discriminator javaType=\"int\" column=\"vehicle_type\"&gt; &lt;case value=\"1\" resultType=\"Car\"&gt; &lt;result property=\"doorCount\" column=\"door_count\" /&gt; &lt;/case&gt; &lt;case value=\"2\" resultType=\"Suv\"&gt; &lt;result property=\"allWheelDrive\" column=\"all_wheel_drive\" /&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id=\"selectVehicleById\" parameterType=\"int\" resultMap=\"vehicleResultMap\"&gt; SELECT * FROM Vehicle WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;select id=\"selectVehicleList\" resultMap=\"vehicleResultMap\"&gt; SELECT * FROM Vehicle &lt;/select&gt; 接口： 1234public interface VehicleMapper &#123; public Vehicle selectVehicleById(Integer id); public List&lt;Vehicle&gt; selectVehicleList();&#125; 测试： 方法1：打印对象地址可以看出对象是多态的 方法2：用断点调试可以发现取出的对象是多态的 123456789101112131415@Test public void testSelectVehicleById() &#123; SqlSession session = MyBatisUtil.getSqlSession(); VehicleMapper vehicleDao = session.getMapper(VehicleMapper.class); /*Car vehicle1 = (Car)vehicleDao.selectVehicleById(1); Suv vehicle3 = (Suv)vehicleDao.selectVehicleById(3);*/ Vehicle vehicle1 = vehicleDao.selectVehicleById(1); Vehicle vehicle3 = vehicleDao.selectVehicleById(3); session.close(); System.out.println(vehicle1); System.out.println(vehicle3); &#125; 23-性能-延迟加载延迟加载又叫懒加载，也叫按需加载。也就是说先加载主信息，在需要的时候，再去加载从信息。 在mybatis中，resultMap标签 的association标签和collection标签具有延迟加载的功能。 1、拷贝jar包 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt;&lt;/dependency&gt; 2、配置全局设置 目前的mybatis版本对 aggressiveLazyLoading 的支持不好？？？ 12345&lt;!-- 全局设置 --&gt; &lt;settings&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt; &lt;/settings&gt; 官方对这两个属性的解释是： lazyLoadingEnabled 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。（是否延迟加载当前对象的关联对象） aggressiveLazyLoading 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。（是否延迟加载当前对象属性的关联对象） 延迟加载会生成代理对象 3、测试 123456789101112131415161718/** * 测试延迟加载 */ @Test public void testSelectBlogLazyLoading()&#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogDao = session.getMapper(BlogMapper.class); System.out.println(\"查询blog\"); Blog blog = blogDao.selectBlogById(3);//执行查询blog的sql语句 //System.out.println(blog); session.close(); System.out.println(\"查询title属性\"); System.out.println(blog.getTitle());//不执行任何sql语句 System.out.println(\"查询author属性\"); System.out.println(blog.getAuthor().getUsername());//执行查询作者的sql语句 System.out.println(\"结束\"); &#125; （1）什么都不配置 查询blog Opening JDBC Connection Created connection 798244209. Setting autocommit to false on JDBC Connection ==&gt; Preparing: SELECT * FROM blog WHERE id = ? ====&gt; Preparing: SELECT * FROM author WHERE id = ? Resetting autocommit to true on JDBC Connection Closing JDBC Connection Returned connection 798244209 to pool. 查询title属性 姚延军的空间 查询author属性 yaoyanjun 结束 （2）配置 只要结果映射中配置了association 则执行懒加载特性：不查询blog的属性，则不执行子查询，一旦查询任意属性则执行子查询(无论查不查author，都会执行author的查询sql) 查询blog Opening JDBC Connection Created connection 798244209. Setting autocommit to false on JDBC Connection ==&gt; Preparing: SELECT * FROM blog WHERE id = ? Resetting autocommit to true on JDBC Connection Closing JDBC Connection Returned connection 798244209 to pool. 查询title属性 Opening JDBC Connection Checked out connection 798244209 from pool. Setting autocommit to false on JDBC Connection ==&gt; Preparing: SELECT * FROM author WHERE id = ? Resetting autocommit to true on JDBC Connection Closing JDBC Connection Returned connection 798244209 to pool. 姚延军的空间 查询author属性 yaoyanjun 结束 （3）配置 author属性将会按需加载：例如如果不查询author，则不会执行author的查询sql 查询blog Opening JDBC Connection Created connection 798244209. Setting autocommit to false on JDBC Connection ==&gt; Preparing: SELECT * FROM blog WHERE id = ? Resetting autocommit to true on JDBC Connection Closing JDBC Connection Returned connection 798244209 to pool. 查询title属性 姚延军的空间 结束 24-逆向工程maven版http://blog.csdn.net/modote9527/article/details/69053751 1、创建maven项目 mybatis03generator 2、创建数据库 oa 执行脚本：权限管理基础表.sql 3、添加依赖 12345678&lt;dependencies&gt; &lt;!-- mybatis逆向工程jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4、添加插件 123456789101112131415161718192021&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;configuration&gt; &lt;!--配置文件的路径--&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 5、resources下创建 generatorConfig.xml 配置参考：https://blog.csdn.net/isea533/article/details/42102297 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;mysql&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt; &lt;!--分隔符--&gt; &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 一些工具 --&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.EqualsHashCodePlugin&quot;&gt;&lt;/plugin&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;&gt;&lt;/plugin&gt; &lt;plugin type=&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;&gt;&lt;/plugin&gt; &lt;commentGenerator&gt; &lt;!--取消时间戳--&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接参数--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/oa_bj1802&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt;&lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;!-- This property is used to specify whether MyBatis Generator should force the use of java.math.BigDecimal for DECIMAL and NUMERIC fields, --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer/Long，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;true&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!--pojo模型的位置和包名--&gt; &lt;javaModelGenerator targetPackage=&quot;com.qfedu.oa.pojo&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--mapper映射文件的位置和包名--&gt; &lt;sqlMapGenerator targetPackage=&quot;com.qfedu.oa.dao&quot; targetProject=&quot;src/main/java&quot;&gt;&lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 XMLMAPPER | ANNOTATEDMAPPER--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.qfedu.oa.dao&quot; targetProject=&quot;src/main/java&quot;&gt;&lt;/javaClientGenerator&gt; &lt;!-- 要生成哪些表 --&gt; &lt;table tableName=&quot;sys_menu&quot; domainObjectName=&quot;SysMenu&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;table tableName=&quot;sys_role&quot; domainObjectName=&quot;SysRole&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;table tableName=&quot;sys_user&quot; domainObjectName=&quot;SysUser&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;table tableName=&quot;sys_role_menu&quot; domainObjectName=&quot;SysRoleMenu&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;table tableName=&quot;sys_user_role&quot; domainObjectName=&quot;SysUserRole&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;table tableName=&quot;sys_config&quot; domainObjectName=&quot;SysConfig&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;table tableName=&quot;sys_log&quot; domainObjectName=&quot;SysLog&quot;&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot; /&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 6、运行 mybatis-generator:generate","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zymmx.github.io/tags/mybatis/"}]},{"title":"SpringMVC详解","slug":"SpringMVC","date":"2018-12-04T13:29:52.677Z","updated":"2018-12-04T13:29:52.678Z","comments":true,"path":"2018/12/04/SpringMVC/","link":"","permalink":"https://zymmx.github.io/2018/12/04/SpringMVC/","excerpt":"","text":"[TOC] SpringMVC一、springmvc框架MVC的概念： M：model，模型层， 一种javabean，是数据库中的表的实体类型的映射 V：view，视图层，jsp页面，和用户交互的一个界面 C：controller，控制层，接受请求，调用业务逻辑，返回结果，调用结果视图 struts2：一个MVC框架 springmvc：是一个在性能上和安全性上更优秀MVC框架 二、springmvc HelloWorld1、创建项目 springmvc01hello 2、pom中设置项目的打包方式为：war 1&lt;packaging&gt;war&lt;/packaging&gt; 3、pom中添加jar包 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4、完善项目目录结构 添加web.xml文件 5、log4j 复制4j.properties文件 6、创建jsp目录和文件 7、创建Controller 1234567891011121314package com.qfedu.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IndexController &#123; @RequestMapping(\"/index\") public String index()&#123; System.out.println(\"index......\"); return \"index\";//视图的名字 &#125;&#125; 8、创建和配置springmvc-servlet.xml 在resources下添加文件 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 扫描controller包下所有标注@Controller的组件 --&gt; &lt;context:component-scan base-package=\"com.qfedu.springmvc.controller\"/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/WEB-INF/jsp/\" p:suffix=\".jsp\" /&gt;&lt;/beans&gt; 9、配置web.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;!-- 配置SpringMVC的 DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置 DispatcherServlet 的一个初始化参数: 配置 springmvc 配置文件的位置和名称 --&gt; &lt;!-- 实际上也可以不通过 contextConfigLocation 来配置 springmvc 的配置文件, 而使用默认的. 默认的配置文件为: /WEB-INF/&lt;servlet-name&gt;-servlet.xml 如：springmvc-servlet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;!-- &lt;param-value&gt;/WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; --&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 所有的客户端请求由 DispatcherServlet处理：前端控制器模式--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; /* 拦截所有请求 / 拦截所有请求，不包括 jsp .do 或 .action 只拦截 do 或 action 扩展名的请求 10、配置tomcat插件 123456789101112131415&lt;build&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;!--配置编码方式为UTF-8--&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 11、启动和运行项目 mvn tomcat7:run 测试路径：http://localhost:8080/index 三、常用注解一、@RequestMapping的位置 1、加在方法前 2、加在类前 例如：创建 /jsp/school/list.jsp 和 SchoolController.java 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;锋舍管理系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;校区管理&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112package com.qfedu.springmvc.controller;@Controller@RequestMapping(\"/school\")public class SchoolController &#123; @RequestMapping(\"/list\") public String list()&#123; return \"school/list\"; &#125;&#125; 重启tomcat，程序的访问路径是：http://localhost:8080/school/list 二、@RequestMapping的请求方式 1、默认情况下，处理器可以同时接收post形式和get形式的请求 例如：创建/jsp/login.jsp 、/jsp/success.jsp 和 LoginController.java login.jsp 123456&lt;h1&gt;登录&lt;/h1&gt;&lt;form action=&quot;do_login&quot;&gt; &lt;p&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;button&gt;登录&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; success.jsp 1&lt;h1&gt;成功&lt;/h1&gt; LoginController.java 1234567891011121314@Controllerpublic class LoginController &#123; @RequestMapping(\"/login\") public String login()&#123; return \"login\"; &#125; @RequestMapping(\"/do_login\") public String doLogin()&#123; return \"success\"; &#125;&#125; 重启tomcat，程序的访问路径是：http://localhost:8080/login 输入用户名和密码程序跳转到：http://localhost:8080/do_login?username=admin&amp;password=12345 此时表单为默认的get形式发送的请求 2、可以将表单的请求方式改为 post 1&lt;form action=&quot;do_login&quot; method=&quot;post&quot;&gt; 刷新页面后重新测试。 3、可以将处理器中的注解修改成只接收post请求的方式 1234@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin()&#123; return \"success\";&#125; 测试：如果请求方式和接收方式不匹配，会发生405错误 4、总结 （1）GET形式：@RequestMapping(value=”/do_login”, method=RequestMethod.GET) 通过URL地址直接访问 或通过a标签的超链接访问 例如：index.jsp中添加 1&lt;div&gt;&lt;a href=&quot;login&quot;&gt;登录&lt;/a&gt;&lt;/div&gt; 表单中的 ajax get （2）POST形式： @RequestMapping(value=”/do_login”, method=RequestMethod.POST) 表单中的 ajax post （3）注意： 如果不明确指定method参数，那么可以接收任何类型的请求 如果明确指定，但是类型不匹配，那么会出现 405 错误 三、处理请求参数 1、在控制层方法的参数中处理请求参数： 参数名和表单中控件的name属性保持一致 可以接收get和post所有形式的传参 123456@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin(String username, String password)&#123; System.out.println(username); System.out.println(password); return \"success\";&#125; 2、@RequestParam处理请求参数 上面的例子也可以写成下面的形式 1public String doLogin(@RequestParam String username, @RequestParam String password)&#123; 或（@RequestParam中的默认参数和表单中控件的name属性保持一致） 1public String doLogin(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password)&#123; 3、配置可选的参数 在控制层添加一个参数：“验证码 code”，测试登录功能发现400错误 12345@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin( @RequestParam(\"username\") String username, @RequestParam(\"password\") String password, @RequestParam(\"code\") String code)&#123; 可以设置：required=false，表示参数是可选的，可以传递也可以不传递。默认值是true，必须传递 1@RequestParam(name = &quot;code&quot;, required = false) String code 4、配置参数的默认值 defaultValue属性可以配置参数的默认值，当参数没有被定义时，使用默认值 1234567891011@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin( @RequestParam(\"username\") String username, @RequestParam(\"password\") String password, /*@RequestParam(name = \"code\", required = false) String code*/ @RequestParam(name = \"code\", defaultValue = \"\") String code)&#123; System.out.println(username); System.out.println(password); System.out.println(\"code = \" + code); return \"success\";&#125; 5、接收参数时，数值类型的参数应该使用包装类类型 否则当前端的字段可以为空时，会报告类型转换错误（400错误） 例如：login.jsp中添加如下字段 1&lt;p&gt;&lt;label for=&quot;number&quot;&gt;数值&lt;/label&gt;&lt;input type=&quot;number&quot; name=&quot;number&quot; id=&quot;number&quot;&gt;&lt;/p&gt; LoginController.jsp中接收参数是int，测试：当不输入number的时候会发生400错误 12345678910111213@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin( @RequestParam(\"username\") String username, @RequestParam(\"password\") String password, /*@RequestParam(name = \"code\", required = false) String code*/ @RequestParam(name = \"code\", defaultValue = \"\") String code, int number)&#123; System.out.println(username); System.out.println(password); System.out.println(\"code = \" + code); System.out.println(\"number = \" + number); return \"success\";&#125; 控制台警告： 警告: Failed to bind request element: org.springframework.beans.TypeMismatchException: Failed to convert value of type ‘java.lang.String’ to required type ‘int’; nested exception is java.lang.NumberFormatException: For input string: “” 将 int 该成 Integer 会解决这个问题 1Integer number 四、@PathVariable 路径传参 通常url中的参数使用queryString，也可以使用路径传参 （1）修改school/list.jsp 1234567891011121314151617&lt;h1&gt;校区管理&lt;/h1&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;校区名称&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"view?id=1\"&gt;天丰利&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"view/1\"&gt;北科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; （2）添加school/view.jsp 12&lt;h1&gt;校区管理&lt;/h1&gt;&lt;h2&gt;详细信息&lt;/h2&gt; （3）修改SchoolController.java 12345678910111213@RequestMapping(\"/view\")public String view1(@RequestParam(\"id\") Integer id)&#123; System.out.println(\"id = \" + id); return \"school/view\";&#125;@RequestMapping(\"/view/&#123;id&#125;\")public String view2(@PathVariable(\"id\") Integer id)&#123; System.out.println(\"id = \" + id); return \"school/view\";&#125; 五、转发和重定向 重定向 123456@RequestMapping(value=&quot;/do_login&quot;, method= RequestMethod.POST)public String doLogin(......)&#123; ...... //return &quot;success&quot;; return &quot;redirect:index&quot;;&#125; 六、乱码 1、解决post乱码问题 web.xml文件 1234567891011121314151617&lt;!-- 字符编码过滤器 : 放在其他过滤器的前面--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2、get乱码问题 get 乱码 和 tomcat 版本有关 tomcat7和7以下 需要 解决乱码问题 tomcat8不用 3、idea乱码 https://www.cnblogs.com/liaoyanglong/p/6639039.html 四、处理模型数据一、使用pojo对象绑定参数 1、创建模型类School.java 1234567public class School &#123; private Integer id; private String name; private String number;&#125; 2、school/form.jsp 12345678&lt;h1&gt;校区管理&lt;/h1&gt;&lt;form action=\"save\" method=\"post\"&gt; &lt;p&gt;&lt;label for=\"name\"&gt;校区名称&lt;/label&gt;&lt;input type=\"text\" name=\"name\" id=\"name\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"number\"&gt;校区编号&lt;/label&gt;&lt;input type=\"text\" name=\"number\" id=\"number\"&gt;&lt;/p&gt; &lt;p&gt; &lt;button&gt;保存&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 3、SchoolController.java 12345678910111213@RequestMapping(\"/add\")public String add()&#123; return \"school/form\";&#125;@RequestMapping(\"/save\")public String save(School school)&#123; System.out.println(school); return \"redirect:list\";&#125; Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配， 自动为该对象填充属性值。 4、测试：http://localhost:8080/school/add 二、复杂的对象 Spring MVC 参数支持级联属性如：.school.name 等 1、创建模型类Apartment.java 123456789101112public class Apartment &#123; private Integer id; private String name; private String number; private String type; private String contractBegin; private String contractEnd; private Integer dormitoryCount; private School school;&#125; 2、创建页面apartment/form.jsp 12345678910111213&lt;h1&gt;公寓管理&lt;/h1&gt;&lt;form action=\"save\" method=\"post\"&gt; &lt;p&gt;&lt;label for=\"schoolName\"&gt;所属校区&lt;/label&gt;&lt;input type=\"text\" name=\"school.name\" id=\"schoolName\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"name\"&gt;公寓名称&lt;/label&gt;&lt;input type=\"text\" name=\"name\" id=\"name\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"type\"&gt;公寓类型&lt;/label&gt;&lt;input type=\"text\" name=\"type\" id=\"type\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"number\"&gt;公寓编号&lt;/label&gt;&lt;input type=\"text\" name=\"number\" id=\"number\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"contractBegin\"&gt;合同租期&lt;/label&gt;&lt;input type=\"text\" name=\"contractBegin\" id=\"contractBegin\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"contractEnd\"&gt;合同到期&lt;/label&gt;&lt;input type=\"text\" name=\"contractEnd\" id=\"contractEnd\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"dormitoryCount\"&gt;宿舍数量&lt;/label&gt;&lt;input type=\"text\" name=\"dormitoryCount\" id=\"dormitoryCount\"&gt;&lt;/p&gt; &lt;p&gt; &lt;button&gt;保存&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 3、创建页面apartment/list.jsp 12&lt;h1&gt;公寓管理&lt;/h1&gt;&lt;div&gt;&lt;a href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/div&gt; 4、创建 ApartmentController.java 123456789101112131415161718192021222324@Controller@RequestMapping(\"/apartment\")public class ApartmentController &#123; @RequestMapping(\"/list\") public String list()&#123; return \"apartment/list\"; &#125; @RequestMapping(\"/add\") public String add()&#123; return \"apartment/form\"; &#125; @RequestMapping(\"/save\") public String save(Apartment apartment)&#123; System.out.println(apartment); return \"redirect:list\"; &#125;&#125; 5、测试 三、ModelAndView处理模型数据 从controller向页面传值，多用于列表页、回显页面 1、修改SchoolController的 list 方法 12345678910111213141516171819@RequestMapping(\"/list\")public ModelAndView list()&#123; //假设从db中取出了数据列表 List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(); for (int i = 0; i &lt; 10; i++) &#123; School school = new School(); school.setId(i + 1); school.setName(\"school \" + 1); school.setNumber(\"number \" + 1); schoolList.add(school); &#125; ModelAndView mv = new ModelAndView(); mv.setViewName(\"school/list\"); mv.addObject(\"schoolList\", schoolList); return mv;&#125; 2、修改 school/list.jsp页面 12345&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 1234567891011121314151617181920&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;校区ID&lt;/th&gt; &lt;th&gt;校区名称&lt;/th&gt; &lt;th&gt;校区编号&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach items=\"$&#123;requestScope.schoolList&#125;\" var=\"school\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;school.id&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"view?id=$&#123;school.id&#125;\"&gt;$&#123;school.name&#125;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;$&#123;school.number&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"view/$&#123;school.id&#125;\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt;&lt;/table&gt; 3、测试 四、Map处理模型数据 1、修改SchoolController的 list 方法 1234567891011121314151617@RequestMapping(\"/list\")public String list(Map&lt;String, Object&gt; map)&#123; //假设从db中取出了数据列表 List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(); for (int i = 0; i &lt; 10; i++) &#123; School school = new School(); school.setId(i + 1); school.setName(\"school \" + 1); school.setNumber(\"number \" + 1); schoolList.add(school); &#125; map.put(\"schoolList\", schoolList); return \"school/list\";&#125; 2、测试 五、Model/ModelMap处理模型数据 还可以使用 Model 或 ModelMap 类替代Map类 五、原生API一、原生API 主要指Servlet中的可用对象，例如： HttpServletRequest、HttpServletResponse、HttpSession 等 需要将如下依赖加入到pom中 12345678910111213&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 二、登陆功能的实现 1、修改doLogin方法 123456789101112131415@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin(HttpServletRequest request, HttpSession session)&#123; String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); if(\"admin\".equals(username) &amp;&amp; \"123\".equals(password))&#123; session.setAttribute(\"username\", username); return \"redirect:index\"; &#125;else&#123; return \"redirect:login\"; &#125;&#125; 4、页面中获取session数据 1&lt;div&gt;当前用户：$&#123;sessionScope.username&#125;&lt;/div&gt; 5、登出的controller方法 index.jsp页面 1&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;&gt;退出&lt;/a&gt; LoginController.java中添加： 123456@RequestMapping(\"/logout\")public String logout(HttpSession session)&#123; //session.removeAttribute(\"username\"); session.invalidate(); return \"redirect:login\";&#125; 六、Spring MVC处理请求的流程（底层原理）一、Spring MVC 的运行原理 执行细节： springmvc 的 DispathcerServlet执行时 会读取默认的配置文件，来加载相关组件： 、核心组件包括：处理器映射器、处理器适配器、视图解析器 、 可以通过在spring mvc的配置文件中配置如下选项修改默认的组件 123456789&lt;!--视图解析器--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" p:prefix=\"/WEB-INF/jsp/\" p:suffix=\".jsp\"&gt;&lt;/bean&gt;&lt;!-- 处理器映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" /&gt;&lt;!-- 处理器适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" /&gt; 二、Spring MVC处理请求的流程 SpringMVC流程 1、 用户发送请求至前端控制器DispatcherServlet。 2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、 DispatcherServlet调用HandlerAdapter处理器适配器。 5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 6、 Controller执行完成返回ModelAndView。 7、 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 8、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 9、 ViewReslover解析后返回具体View。 10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 11、 DispatcherServlet响应用户。 组件说明： DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。 ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。 组件：1、前端控制器DispatcherServlet（不需要工程师开发）,由框架提供作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 2、处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用：根据请求的url查找HandlerHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 3、处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4、处理器Handler(需要工程师开发)注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行HandlerHandler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 5、视图解析器View resolver(不需要工程师开发),由框架提供作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 6、视图View(需要工程师开发jsp…)View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…） 七、静态资源访问一、静态资源访问 1、创建 webapp/css/web.css 123h1&#123; color: blue;&#125; 2、在login.jsp中加入静态资源文件 1234&lt;head&gt; &lt;title&gt;锋舍管理系统&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/web.css&quot;&gt;&lt;/head&gt; 刷新后，发现脚本无法被加载，因为所有请求通过前端控制器拦截，springMVC无法找到脚本的路径请求对应的视图，所以报告404错误 3、处理静态资源 在spring-mvc.xml文件中添加 12345&lt;!-- 配置注解驱动 --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 处理静态资源 --&gt;&lt;!-- 所有以/css路径开头的请求不会经过springMVC的DispatcherServlet，而是由/css目录提供服务 --&gt;&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot; /&gt; 二、SpringMVC访问静态资源的三种方式 https://blog.csdn.net/u012730299/article/details/51872704 如果你的DispatcherServlet拦截 .do这样的URL，就不存在访问不到静态资源的问题。如果你的DispatcherServlet拦截“/”，拦截了所有的请求，同时对.js,*.jpg的访问也就被拦截了。 问题原因：罪魁祸首是web.xml下对spring的DispatcherServlet请求url映射的配置 分析原因：的/把所有的请求都交给spring去处理了 方案一：激活Tomcat的defaultServlet来处理静态文件 在web.xml里添加如下配置 123456789101112&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 要写在DispatcherServlet的前面， 让defaultServlet先拦截，这个就不会进入Spring了，我想性能是最好的吧。 Tomcat, Jetty, JBoss, and GlassFish 默认 Servlet的名字 – “default”Google App Engine 默认 Servlet的名字 – “_ah_default”Resin 默认 Servlet的名字 – “resin-file”WebLogic 默认 Servlet的名字 – “FileServlet”WebSphere 默认 Servlet的名字 – “SimpleFileServlet” 方案二： 在spring3.0.4以后版本提供了mvc:resources 12345&lt;!-- 配置注解驱动 --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 处理静态资源 --&gt;&lt;!-- 所有以/css路径开头的请求不会经过springMVC的DispatcherServlet，而是由/css目录提供服务 --&gt;&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot; /&gt; /css/**映射到通过DispatcherServlet进入 ResourceHttpRequestHandler 进行处理，location指定静态资源的位置 mapping：映射 location：本地资源路径，注意必须是webapp目录下的路径。 两个*，它表示映射resources/下所有的URL，包括子路径 注意： 一定要配置 &lt;mvc:annotation-driven /&gt; 配置的location一定要是webapp根目录下才行，如果你将资源目录，放置到webapp/WEB-INF下面的话，则就会访问失败。 WEB-INF目录作用WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 当然，你非要放在WEB-INF中，则必须修改resources映射，如： 1&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/css/&quot; /&gt; 方案三：使用mvc:default-servlet-handler/ 123&lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:default-servlet-handler/&gt; mvc:default-servlet-handler/会把 “/**” url,注册到 SimpleUrlHandlerMapping 的 urlMap 中 把对静态资源的访问由 HandlerMapping 转到 org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler 处理并返回 DefaultServletHttpRequestHandler 使用就是各个 Servlet 容器自己的默认 Servlet 补充说明：多个HandlerMapping的执行顺序问题：DefaultAnnotationHandlerMapping 的 order 属性值是：0&lt;mvc:resources/ &gt;自动注册的 SimpleUrlHandlerMapping 的 order 属性值是： 2147483646mvc:default-servlet-handler/自动注册的 SimpleUrlHandlerMapping 的 order 属性值是：2147483647spring 会先执行 order 值比较小的。当访问一个 a.jpg 图片文件时，先通过 DefaultAnnotationHandlerMapping 来找处理器，一定是找不到的，我们没有叫 a.jpg 的 Action。再按 order 值升序找，由于最后一个 SimpleUrlHandlerMapping 是匹配 “/**” 的，所以一定会匹配上，再响应图片。 最后再说明一下，如何你的 DispatcherServlet 拦截 *.do 这样的 URL，就不存上述问题了。 八、拦截器一、什么是拦截器 java里的拦截器是动态拦截Controller/Action调用的对象。 它提供了一种机制可以使开发者在一个Controller执行的前后执行的代码，也可以在一个Controller执行前阻止其执行。 同时也提供了一种可以提取Controller中可重用部分的方式。 在AOP（Aspect-Oriented Programming）中拦截器用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。 二、实现一个拦截器 1、实现接口HandlerInterceptor创建拦截器（创建相同的拦截器1和2） 123456789101112131415161718192021222324252627282930313233343536373839404142package com.qfedu.springmvc.controller.interceptor;public class HandlerInterceptor1 implements HandlerInterceptor &#123; /** * 在执行handler之前来执行的 * 用于用户认证校验、用户权限校验 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"HandlerInterceptor1...preHandle\"); //如果返回false表示拦截不继续执行handler，如果返回true表示放行 return true; &#125; /** * 在执行handler返回modelAndView之前来执行 * 如果需要向页面提供一些公用的数据或配置一些视图信息，使用此方法实现 * 可以再次配置modelAndView */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"HandlerInterceptor1...postHandle\"); &#125; /** * 执行handler之后执行此方法 * 如统一日志记录、方法执行性能监控： * 在preHandle中设置一个时间点，在afterCompletion设置一个时间，两个时间点的差就是执行时长 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"HandlerInterceptor1...afterCompletion\"); &#125;&#125; 2、在spring-mvc.xml中配置拦截器 12345678910111213&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;!-- /**可以拦截路径不管多少层 --&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.qfedu.springmvc.controller.interceptor.HandlerInterceptor1\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;bean class=\"com.qfedu.springmvc.controller.interceptor.HandlerInterceptor2\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 3、测试拦截器 测试1 （1 号和2号都放行） 测试结果： HandlerInterceptor1…preHandle HandlerInterceptor2…preHandle HandlerInterceptor2…postHandle HandlerInterceptor1…postHandle HandlerInterceptor2…afterCompletion HandlerInterceptor1…afterCompletion 总结： 执行preHandle是顺序执行。 执行postHandle、afterCompletion是倒序执行 测试2 （1 号放行和2号不放行） 测试结果： HandlerInterceptor1…preHandle HandlerInterceptor2…preHandle HandlerInterceptor1…afterCompletion 总结： 如果preHandle不放行，postHandle、afterCompletion都不执行。 只要有一个拦截器不放行，controller不能执行完成 测试3 （1 、2号都不放行） 测试结果： HandlerInterceptor1…preHandle 总结： 只有前边的拦截器preHandle方法放行，下边的拦截器的preHandle才执行。 三、实现用户认证拦截 1、确认已有login.jsp 2、确认已有index.jsp 12345678&lt;div&gt;&lt;a href=&quot;login&quot;&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;div&gt; 当前用户：$&#123;sessionScope.username&#125; &lt;c:if test=&quot;$&#123;sessionScope.username!=null &#125;&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;&gt;退出&lt;/a&gt; &lt;/c:if&gt;&lt;/div&gt;&lt;h1&gt;欢迎访问&lt;/h1&gt; 3、确认已有LoginController.java 4、定义拦截器：使用HandlerInterceptorAdapter 1234567891011121314151617181920212223242526272829303132package com.qfedu.springmvc.controller.interceptor;public class LoginInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //得到请求的url String url = request.getRequestURI(); //判断是否是公开地址 if(url.indexOf(\"login\")&gt;=0)&#123; //如果是公开 地址则放行 return true; &#125; //判断用户身份在session中是否存在 HttpSession session = request.getSession(); String username = (String) session.getAttribute(\"username\"); //如果用户身份在session中存在放行 if(username != null)&#123; return true; &#125; //执行到这里拦截，跳转到登录页面，用户进行身份认证 String contextPath = request.getContextPath(); response.sendRedirect(contextPath + \"/login\"); //如果返回false表示拦截不继续执行handler，如果返回true表示放行 return false; &#125;&#125; 5、配置拦截器 12345&lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\" /&gt; &lt;mvc:exclude-mapping path=\"/css/**\"/&gt; &lt;bean class=\"com.qfedu.springmvc.controller.interceptor.LoginInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; 面试题 谈谈过滤器的作用 过滤器，是在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符 谈谈拦截器的作用 拦截器，是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。 拦截器和过滤器有什么区别 拦截器是基于java的反射机制的，而过滤器是基于函数回调。 拦截器不依赖servlet容器，过滤器依赖与servlet容器。 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 执行顺序：过滤前 – 拦截前 – Action处理 – 拦截后 – 过滤后。个人认为过滤是一个横向的过程，首先把客户端提交的内容进行过滤(例如未登录用户不能访问内部页面的处理)；过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的Action；Action处理完成返回后，拦截器还可以做其他过程(还没想到要做啥)，再向上返回到过滤器的后续操作。 九、数据的格式化一、自动数据类型转换 1、创建实体模型 Checkout.java 123456789101112package com.qfedu.springmvc.pojo;import java.util.Date;/** * 退宿管理 */public class Checkout &#123; private Integer id; private Integer numberOfBed; //床位数 private Float cost; //月住宿费 private Date checkinDate; //入住日期&#125; 2、创建页面 checkout/list.jsp，checkout/form.jsp list 12&lt;h1&gt;退宿管理&lt;/h1&gt;&lt;div&gt;&lt;a href=&quot;add&quot;&gt;添加&lt;/a&gt;&lt;/div&gt; form 123456789&lt;h1&gt;公寓管理&lt;/h1&gt;&lt;form action=\"save\" method=\"post\"&gt; &lt;p&gt;&lt;label for=\"numberOfBed\"&gt;床位数&lt;/label&gt;&lt;input type=\"text\" name=\"numberOfBed\" id=\"numberOfBed\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"cost\"&gt;月住宿费&lt;/label&gt;&lt;input type=\"text\" name=\"cost\" id=\"cost\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"checkinDate\"&gt;入住日期&lt;/label&gt;&lt;input type=\"text\" name=\"checkinDate\" id=\"checkinDate\"&gt;&lt;/p&gt; &lt;p&gt; &lt;button&gt;保存&lt;/button&gt; &lt;/p&gt;&lt;/form&gt; 3、创建CheckoutController.java 123456789101112131415161718192021222324@Controller@RequestMapping(\"/checkout\")public class CheckoutController &#123; @RequestMapping(\"/list\") public String list()&#123; return \"checkout/list\"; &#125; @RequestMapping(\"/add\") public String add()&#123; return \"checkout/form\"; &#125; @RequestMapping(\"/save\") public String save(Checkout checkout)&#123; System.out.println(checkout); return \"redirect:list\"; &#125;&#125; 4、测试 发生 400 错误 特殊类型的数据无法自动格式化 屏蔽Date和Float 自定义模型、Integer类型等可以自动转换 二、使用注解实现数据类型转换 1、pojo中添加注解** 使输入类型匹配货币格式：需要在表单中输入 ￥100.100 12@NumberFormat(style= NumberFormat.Style.CURRENCY)//货币类型private Float cost; //月住宿费 使输入类型匹配货币格式：需要在表单中输入 2018-01-01 12@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)//日期类型private Date checkinDate; //入住日期 2、测试 三、自定义日期类型转换器 也可以不使用注解，使用自定义日期类型转换器，转换更灵活 1、创建DateConverter.java 12345678910111213141516171819package com.qfedu.springmvc.controller.converter;public class DateConverter implements Converter&lt;String, Date&gt; &#123; /** * 将字符串转换成日期格式 */ @Override public Date convert(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); try &#123; sdf.setLenient(false);//是否宽松解析：默认true return sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2、spring-mvc配置文件 添加自定义转换器 1234567891011&lt;!-- 配置注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\" /&gt;&lt;!-- 配置自定义类型转换器 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.qfedu.springmvc.controller.converter.DateConverter\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 四、自定义类型转换器完成数据添加 1、添加list.jsp 1234&lt;div&gt; &lt;a href=&quot;add&quot;&gt;添加&lt;/a&gt; &lt;a href=&quot;add_batch&quot;&gt;批量添加&lt;/a&gt;&lt;/div&gt; 2、添加add_batch.jsp 1234567&lt;h1&gt;公寓管理&lt;/h1&gt;&lt;!-- 将字符串转换为Checkout对象 --&gt;&lt;form action=\"save_batch\" method=\"post\"&gt; &lt;!-- property1|property2|property3 例如: 100|100.25|2018-01-01 --&gt; 退宿信息: &lt;input type=\"text\" name=\"checkout\" id=\"checkout\"&gt; &lt;button&gt;保存&lt;/button&gt;&lt;/form&gt; 3、修改CheckoutController.jsp 12345678910111213141516@RequestMapping(\"/add_batch\")public String addBatch()&#123; return \"checkout/add_batch\";&#125;@RequestMapping(\"/save_batch\")public String saveBatch(Checkout checkout)&#123; /*for (Checkout checkout : checkoutList) &#123; System.out.println(checkout); &#125;*/ System.out.println(checkout); return \"redirect:list\";&#125; 4、创建转换器类 1234567891011121314151617181920212223242526272829303132package com.qfedu.springmvc.controller.converter;public class CheckoutConverter implements Converter&lt;String, Checkout&gt; &#123; @Override public Checkout convert(String source) &#123; System.out.println(source); if(source != null) &#123; String[] values = source.split(\"\\\\|\"); //100|100.25|2018-01-01 if (values != null &amp;&amp; values.length == 3) &#123; Integer numberOfBed = Integer.parseInt(values[0]); Float cost = Float.parseFloat(values[1]); Date checkinDate = null; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); try &#123; sdf.setLenient(false);//是否宽松解析：默认true 例如：33号是否合法 checkinDate = sdf.parse(values[2]); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Checkout checkout = new Checkout(); checkout.setNumberOfBed(numberOfBed); checkout.setCost(cost); checkout.setCheckinDate(checkinDate); return checkout; &#125; &#125; return null; &#125;&#125; 5、mvc配置文件 1234&lt;list&gt; &lt;bean class=&quot;com.qfedu.springmvc.controller.converter.DateConverter&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;com.qfedu.springmvc.controller.converter.CheckoutConverter&quot;&gt;&lt;/bean&gt;&lt;/list&gt; 6、测试 十、List和Array的数据类型转换一、列表和数组形式的参数 1、url http://localhost:8080/checkout/delete_batch?ids=1&amp;ids=2&amp;ids=3 2、CheckoutController.java 注意：参数前必须添加@RequestParam(value=”ids”)注解，否则参数没有办法赋值 123456@RequestMapping(&quot;/delete_batch&quot;)public String deleteBatch(@RequestParam(value=&quot;ids&quot;) List&lt;Integer&gt; ids)&#123; System.out.println(ids); return &quot;redirect:list&quot;;&#125; 或 12345678@RequestMapping(&quot;/delete_batch1&quot;)public String deleteBatch1(@RequestParam(value=&quot;ids&quot;) String[] ids)&#123; System.out.println(ids[0]); System.out.println(ids[1]); System.out.println(ids[2]); return &quot;redirect:list&quot;;&#125; 十一、全局异常处理一、简单异常处理 1、修改LoginController.java 12345678910111213@RequestMapping(value=\"/do_login\", method= RequestMethod.POST)public String doLogin(HttpServletRequest request, HttpSession session) throws Exception &#123; String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); if(StringUtils.isEmpty(username))&#123; throw new Exception(\"用户名为空\"); &#125; if(StringUtils.isEmpty(password))&#123; throw new Exception(\"密码为空\"); &#125; 2、LoginController.java中添加异常处理函数 如果当前controller中发生Exception异常，那么应用程序会自动调用 @ExceptionHandler(Exception.class) 所标注的方法 1234@ExceptionHandler(Exception.class)public String handleException()&#123; return &quot;error&quot;;&#125; 3、添加WEB-INF/jsp/error.jsp页面： 1&lt;h1&gt;错误页面&lt;/h1&gt; 4、测试 二、自定义异常和捕获精确异常 1、自定义异常如下： 1234567891011121314package com.qfedu.springmvc.exception;public class StringEmptyException extends Exception&#123; private static final long serialVersionUID = 1L; public StringEmptyException() &#123; super(); &#125; public StringEmptyException(String message) &#123; super(message); &#125;&#125; 2、修改异常抛出的代码： 1234567if(StringUtils.isEmpty(username))&#123; throw new StringEmptyException(\"用户名为空\");&#125;if(StringUtils.isEmpty(password))&#123; throw new StringEmptyException(\"密码为空\");&#125; 3、在LoginController中添加如下方法，捕获Exception异常 注意： 1、如果想要向error页面传递参数，应该使用ModelAndView，不可以使用Map参数 2、在 @ExceptionHandler方法中加入 Exception 类型的参数，该参数对应捕获的异常对象 1234567@ExceptionHandler(StringEmptyException.class)public ModelAndView handleStringEmptyException(StringEmptyException e)&#123; ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;error&quot;); mv.addObject(&quot;message&quot;, &quot;错误：&quot; + e.getMessage()); return mv;&#125; 4、error.jsp页面 12&lt;h1&gt;错误页面&lt;/h1&gt;&lt;p&gt;$&#123;requestScope.message&#125;&lt;/p&gt; 三、全局异常处理 1、创建全局异常处理类 包： com.qfedu.springmvc.exception.handler 类： 123456789101112package com.qfedu.springmvc.exception.handler;@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(StringEmptyException.class) public ModelAndView handleStringEmptyException(StringEmptyException e) &#123; ModelAndView mv = new ModelAndView(); mv.setViewName(\"error\"); mv.addObject(\"message\", \"全局异常处理错误：\" + e.getMessage()); return mv; &#125;&#125; 2、在springMVC-servlet.xml中添加如下配置 注意：必须有mvc:annotation-driven/ 12&lt;!--扫描切面--&gt;&lt;context:component-scan base-package=&quot;com.qfedu.springmvc.exception.handler&quot;/&gt; 3、测试 注意：应用程序出错后会首先执行LoginController中的如下方法 12@ExceptionHandler(StringEmptyException.class)public ModelAndView handleStringEmptyException(StringEmptyException e) 如果没有，只执行LoginController中的如下方法 1234@ExceptionHandler(Exception.class)public String handleException()&#123; return &quot;error&quot;;&#125; 如果当前Controller中没有任何异常处理方法，则应用程序才会执行全局异常处理部分的代码 异常处理的优先级由高到低： 当前Controller的具体异常处理方法 当前Controller的父类异常处理方法 全局异常处理方法 十二、SpringMVC文件上传一、准备项目 1、创建新maven项目：springmvc02upload 1&lt;packaging&gt;war&lt;/packaging&gt; 2、加入springmvc和文件上传相关的jar包 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、配置web.xml：前端控制器、post乱码 4、log4j.properties 5、**创建SpringMVC配置文件** spring/spring-mvc.xml：包扫描、视图解析器、注解驱动 使用文件上传必须开启注解驱动&lt;mvc:annotation-driven /&gt; 6、jsp文件夹 7、controller包 9、配置tomcat 配置server、deployment ### 二、文件上传功能 1、配置虚拟目录 2、修改SpringMVC配置文件 添加如下配置 12345678&lt;!-- 配置 MultipartResolver 处理文件上传 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;!-- 默认编码 (ISO-8859-1) --&gt; &lt;property name=\"maxInMemorySize\" value=\"10240\"/&gt; &lt;!-- 最大内存大小 (10240)--&gt; &lt;property name=\"uploadTempDir\" value=\"/upload/\"/&gt; &lt;!-- 上传后的目录名 --&gt; &lt;property name=\"maxUploadSize\" value=\"-1\"/&gt; &lt;!-- 最大文件大小，单位是字节，-1为无限制 --&gt;&lt;/bean&gt; 3、制作文件上传表单 在jsp文件夹中创建fileupload.jsp 1234567&lt;form action=\"fileupload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件：&lt;input type=\"file\" name=\"file\"&gt; &lt;br&gt; 描述：&lt;input name=\"desc\"&gt; &lt;br&gt; &lt;button&gt;上传&lt;/button&gt;&lt;/form&gt; 4、创建控制器 1234567891011121314151617181920212223242526272829303132333435package com.qfedu.springmvc.controller;@Controllerpublic class UploadController &#123; @RequestMapping(\"/form\") public String form()&#123; return \"fileupload\"; &#125; @RequestMapping(\"fileupload\") public String fileupload( @RequestParam(\"desc\") String desc, @RequestParam(\"file\") MultipartFile file, Map&lt;String, Object&gt; map) throws IllegalStateException, IOException &#123; System.out.println(desc); System.out.println(file); if(file != null &amp;&amp; file.getOriginalFilename() != null &amp;&amp; file.getOriginalFilename().length() &gt; 0)&#123; //图片上传成功后，将图片的地址写到数据库 String filePath = \"D:\\\\upload\\\\\"; //上传文件原始名称 String originalFilename = file.getOriginalFilename(); //新的图片名称 String uuid = UUID.randomUUID().toString() ; String newFileName = uuid + originalFilename.substring(originalFilename.lastIndexOf(\".\")); //新文件 File uploadFile = new File(filePath + newFileName); //将内存中的文件写入磁盘 file.transferTo(uploadFile); map.put(\"url\", \"/upload/\" + newFileName); &#125; return \"success\"; &#125;&#125; 5、jsp中创建成功页：success.jsp 12&lt;h3&gt;成功&lt;/h3&gt;&lt;img src=&quot;$&#123;url&#125;&quot;&gt; 十三、JSON一、准备项目 1、创建新maven项目：springmvc03json 1&lt;packaging&gt;war&lt;/packaging&gt; 2、加入jar包 spring-webmvc、jstl、javax.servlet-api、jsp-api、junit 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、配置web.xml：前端控制器、post乱码 4、log4j.properties 5、**创建SpringMVC配置文件** spring/spring-mvc.xml：包扫描、视图解析器、注解驱动 使用json必须开启注解驱动&lt;mvc:annotation-driven /&gt; 6、jsp文件夹 7、controller包 9、配置tomcat 配置server、deployment ### 二、校区管理 1、复制pojo 2、复制controller 3、复制jsp 4、测试：http://localhost:8080/school/list 三、响应JSON 前后端分离开发中需要JSON数据作为数据传输的格式 1、引入jar包 否则会有 No converter found for return value of type异常 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.10&lt;/version&gt;&lt;/dependency&gt; 2、响应json 修改schoolController中的list方法 1234567891011121314151617@ResponseBody@RequestMapping(\"/list\")public List&lt;School&gt; list()&#123; //假设从db中取出了数据列表 List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(); for (int i = 0; i &lt; 10; i++) &#123; School school = new School(); school.setId(i + 1); school.setName(\"school \" + 1); school.setNumber(\"number \" + 1); schoolList.add(school); &#125; return schoolList;&#125; 四、请求json 1、加入js 2、spring mvc配置中加入静态资源解析 12&lt;!-- 处理静态资源 --&gt;&lt;mvc:default-servlet-handler /&gt; 3、表单form.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;锋舍管理系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;校区管理&lt;/h1&gt;&lt;form action=\"save\" method=\"post\" id=\"myform\"&gt; &lt;p&gt;&lt;label for=\"name\"&gt;校区名称&lt;/label&gt;&lt;input type=\"text\" name=\"name\" id=\"name\"&gt;&lt;/p&gt; &lt;p&gt;&lt;label for=\"number\"&gt;校区编号&lt;/label&gt;&lt;input type=\"text\" name=\"number\" id=\"number\"&gt;&lt;/p&gt; &lt;p&gt; &lt;button type=\"button\" onclick=\"save()\"&gt;保存&lt;/button&gt; &lt;/p&gt;&lt;/form&gt;&lt;script src=\"$&#123;pageContext.request.contextPath &#125;/lib/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; /* 添加数据 */ function save()&#123; var data = &#123; name: $('#name').val(), number: $('#number').val() &#125;; $.ajax(&#123; url: \"save\", type:\"post\", contentType:\"application/json;charset=utf-8\", //请求json数据,使用json表示商品信息 data:JSON.stringify(data), success:function(result)&#123; console.log(result); &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; javascript：JSON转换 var aToStr=JSON.stringify(a); //将对象转成json字符串 var bToObj=JSON.parse(b); //将json字符串转成对象 4、controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qfedu.springmvc.controller;import com.qfedu.springmvc.pojo.School;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.List;@Controller@RequestMapping(\"/school\")public class SchoolController &#123; @ResponseBody @RequestMapping(\"/list\") public List&lt;School&gt; list()&#123; //假设从db中取出了数据列表 List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(); for (int i = 0; i &lt; 10; i++) &#123; School school = new School(); school.setId(i + 1); school.setName(\"school \" + 1); school.setNumber(\"number \" + 1); schoolList.add(school); &#125; return schoolList; &#125; @RequestMapping(\"/add\") public String add()&#123; return \"school/form\"; &#125; @ResponseBody @RequestMapping(\"/save\") public Map&lt;String, Object&gt; save(@RequestBody School school)&#123; System.out.println(school); Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(\"code\", 0); result.put(\"msg\", \"保存成功\"); return result; &#125;&#125; 根据返回结果前端提示 123if(result.code == 0)&#123; alert(result.msg);&#125; 5、测试 五、返回R对象 1、定义R对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.qfedu.springmvc.dto;import java.util.HashMap;import java.util.Map;public class R extends HashMap&lt;String, Object&gt; &#123; private static final long serialVersionUID = 1L; public R() &#123; put(\"code\", 0); &#125; public static R error() &#123; return error(500, \"未知异常，请联系管理员\"); &#125; public static R error(String msg) &#123; return error(500, msg); &#125; public static R error(int code, String msg) &#123; R r = new R(); r.put(\"code\", code); r.put(\"msg\", msg); return r; &#125; public static R ok(String msg) &#123; R r = new R(); r.put(\"msg\", msg); return r; &#125; public static R ok(Map&lt;String, Object&gt; map) &#123; R r = new R(); r.putAll(map); return r; &#125; public static R ok() &#123; return new R(); &#125; public R put(String key, Object value) &#123; super.put(key, value); return this; &#125;&#125; 2、使用R对象 1234567@ResponseBody@RequestMapping(\"/save\")public R save(@RequestBody School school)&#123; System.out.println(school); return R.ok(\"保存成功\");&#125; 1234567891011121314151617@ResponseBody@RequestMapping(\"/list\")public R list()&#123; //假设从db中取出了数据列表 List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(); for (int i = 0; i &lt; 10; i++) &#123; School school = new School(); school.setId(i + 1); school.setName(\"school \" + 1); school.setNumber(\"number \" + 1); schoolList.add(school); &#125; return R.ok().put(\"data\", schoolList);&#125; 十四、RESTful一、REST REST：即 Representational State Transfer，（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便， 所以正得到越来越多网站的采用。 具体说，就是 HTTP 协议里面，四个表示操作方式的动 词： GET、POST、PUT、DELETE。 它们分别对应四种基本操作： GET 用来获 取资源 POST 用来新建资源 PUT 用来更新资源 DELETE 用来删除资源 URL示例 ： /orders HTTP GET ：得到order列表 （列表页） /order/1 HTTP GET ：得到 id = 1 的 order （回显页） /order/1 HTTP DELETE：删除 id = 1的 order （执行删除） /order/1 HTTP PUT：更新id = 1的 order （执行更新） /order HTTP POST：新增 order （执行插入） HiddenHttpMethodFilter：浏览器 form 表单只支持 GET 和 POST 请求，不支 持 DELETE、PUT请求 ， Spring添加了一个过滤器，可以将这些请求转换 为标准的 http 方法，支持 GET、POST、PUT 和 DELETE 请求。 二、使用result实现CRUD 1、在web.xml中配置 123456789101112&lt;!-- 配置 org.springframework.web.filter.HiddenHttpMethodFilter: 可以把 POST 请求转为 DELETE 或 PUT 请求 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2、controller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.qfedu.springmvc.controller;@Controller@RequestMapping(\"/api2\")public class SchoolController2 &#123; /** * Rest 风格的 URL. * 以 CRUD 为例: * 列表: /schools GET * 新增: /school POST * 修改: /school/1 PUT update?id=1 * 获取: /school/1 GET get?id=1 * 删除: /school/1 DELETE delete?id=1 * */ @ResponseBody @RequestMapping(value = \"/schools\", method = RequestMethod.GET) public R list()&#123; //假设从db中取出了数据列表 List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(); for (int i = 0; i &lt; 10; i++) &#123; School school = new School(); school.setId(i + 1); school.setName(\"school \" + 1); school.setNumber(\"number \" + 1); schoolList.add(school); &#125; return R.ok().put(\"data\", schoolList); &#125; @ResponseBody @RequestMapping(value = \"/school\", method = RequestMethod.POST) public R save(@RequestBody School school)&#123; System.out.println(school); return R.ok(\"保存成功\"); &#125; @ResponseBody @RequestMapping(value = \"/school/&#123;id&#125;\", method = RequestMethod.PUT) public R update(@RequestBody School school, @PathVariable Integer id)&#123; System.out.println(school); return R.ok(\"更新成功\"); &#125; @ResponseBody @RequestMapping(value = \"/school/&#123;id&#125;\", method = RequestMethod.GET) public R view(@PathVariable(\"id\") Integer id)&#123; System.out.println(\"id = \" + id); return R.ok(); &#125; @ResponseBody @RequestMapping(value = \"/school/&#123;id&#125;\", method = RequestMethod.DELETE) public R delete(@PathVariable(\"id\") Integer id)&#123; System.out.println(\"id = \" + id); return R.ok(); &#125;&#125; 3、使用postman测试 4、模拟持久层数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.qfedu.springmvc.controller;import com.qfedu.springmvc.dto.R;import com.qfedu.springmvc.pojo.School;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.atomic.AtomicInteger;@RestController@RequestMapping(\"/api3\")public class SchoolController3 &#123; static Map&lt;Integer, School&gt; map = new HashMap&lt;Integer, School&gt;(); static &#123; for (int i = 0; i &lt; 10; i++) &#123; Integer id = i + 1; School school = new School(); school.setId(id); school.setName(\"校区\" + id); school.setNumber(\"编号\" + id); map.put(id, school); &#125; &#125; @GetMapping(\"/schools\") public R list()&#123; List&lt;School&gt; schoolList = new ArrayList&lt;School&gt;(map.values()); return R.ok().put(\"data\", schoolList); &#125; //原子变量，方便生成自增序列 static AtomicInteger seq = new AtomicInteger(10); @PostMapping(\"/school\") public R save(@RequestBody School school)&#123; //模拟数据库生成自增长主键 Integer id = seq.incrementAndGet(); school.setId(id); map.put(id, school); //将携带主键的school对象作为响应返回 return R.ok(\"保存成功\").put(\"school\", school); &#125; @PutMapping(\"/school/&#123;id&#125;\") public R update(@RequestBody School school, @PathVariable Integer id)&#123; //从持久层中获取数据 School school1 = map.get(id); //根据远程传递过来的参数修改数据 school1.setName(school.getName()); school1.setNumber(school.getNumber()); //更新持久层的数据 map.put(id, school); return R.ok(\"更新成功\"); &#125; @GetMapping(\"/school/&#123;id&#125;\") public R view(@PathVariable(\"id\") Integer id)&#123; School school = map.get(id); return R.ok().put(\"school\", school); &#125; @DeleteMapping(\"/school/&#123;id&#125;\") public R delete(@PathVariable(\"id\") Integer id) &#123; map.remove(id); return R.ok(\"删除成功\"); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zymmx.github.io/tags/SpringMVC/"}]},{"title":"Spring详解","slug":"Spring","date":"2018-12-04T10:33:02.597Z","updated":"2018-12-04T11:12:45.798Z","comments":true,"path":"2018/12/04/Spring/","link":"","permalink":"https://zymmx.github.io/2018/12/04/Spring/","excerpt":"","text":"[TOC] Spring一、什么是springSpring框架，由Rod Johnson开发 Spring是一个非常活跃的开源框架, 基于IOC和AOP来构架多层JavaEE系统，以帮助分离项目组件之间的依赖关系 二、核心概念IoC：Inversion of Control 控制反转 DI：Dependency Injection,依赖注入 AOP：Aspect Oriented Programming 面向切面编程 三、Spring的组成Spring框架包含的功能大约由20个模块组成。这些模块按组可分为核心容器、数据访问/集成，Web，AOP(面向切面编程)、设备、消息和测试 核心模块：Beans、Core、Context、SpEL对应四个初始化项目时需要的四个核心包 四、模块介绍 GroupId ArtifactId 说明 org.springframework spring-beans Beans 支持，包含 Groovy org.springframework spring-aop 基于代理的AOP支持 org.springframework spring-aspects 基于AspectJ 的切面 org.springframework spring-context 应用上下文运行时，包括调度和远程抽象 org.springframework spring-context-support 支持将常见的第三方类库集成到 Spring 应用上下文 org.springframework spring-core 其他模块所依赖的核心模块 org.springframework spring-expression Spring 表达式语言，SpEL org.springframework spring-instrument JVM 引导的仪表（监测器）代理 org.springframework spring-instrument-tomcat Tomcat 的仪表（监测器）代理 org.springframework spring-jdbc 支持包括数据源设置和 JDBC 访问支持 org.springframework spring-jms 支持包括发送/接收JMS消息的助手类 org.springframework spring-messaging 对消息架构和协议的支持 org.springframework spring-orm 对象/关系映射，包括对 JPA 和 Hibernate 的支持 org.springframework spring-oxm 对象/XML 映射（Object/XML Mapping，OXM） org.springframework spring-test 单元测试和集成测试支持组件 org.springframework spring-tx 事务基础组件，包括对 DAO 的支持及 JCA 的集成 org.springframework spring-web web支持包，包括客户端及web远程调用 org.springframework spring-webmvc REST web 服务及 web 应用的 MVC 实现 org.springframework spring-webmvc-portlet 用于 Portlet 环境的MVC实现 org.springframework spring-websocket WebSocket 和 SockJS 实现，包括对 STOMP 的支持 五、模块详解1、core - 核心模块 spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-context-support spring-expression：spring表达式语言 核心模块说明 （1）spring-core 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类 （2）spring-beans 这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI支持，引入spring-core.jar及spring- beans.jar文件就可以了 （3）spring-context Spring核心提供了大量扩展，这样使得由 Core 和 Beans 提供的基础功能增强：这意味着Spring 工程能以框架模式访问对象。Context 模块继承了Beans 模块的特性并增加了对国际化（例如资源绑定）、事件传播、资源加载和context 透明化（例如 Servlet container）。同时，也支持JAVA EE 特性，例如 EJB、 JMX 和 基本的远程访问。Context 模块的关键是 ApplicationContext 接口。spring-context-support 则提供了对第三方库集成到 Spring-context 的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。 （4）spring-expression 为在运行时查询和操作对象图提供了强大的表达式语言。它是JSP2.1规范中定义的统一表达式语言的扩展，支持 set 和 get 属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。 2、Data Access/Integration - 数据访问与集成 数据访问与集成层包含 JDBC、ORM、OXM、JMS和事务模块。 详细说明 （1）spring-jdbc 提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析。 （2）spring-tx 支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细。 （3）spring-orm 提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理。 （4）spring-oxm 模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 （5）spring-jms 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块 3、Web Web 层包括 spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet 等模块。 详细说明 （1）spring-web 提供面向 web 的基本功能和面向 web 的应用上下文，比如 multipart 文件上传功能、使用 Servlet 监听器初始化 IoC 容器等。它还包括 HTTP 客户端以及 Spring 远程调用中与 web 相关的部分 （2）spring-webmvc 为 web 应用提供了模型视图控制（MVC）和 REST Web 服务的实现。Spring 的 MVC 框架可以使领域模型代码和 web 表单完全地分离，且可以与 Spring 框架的其它所有功能进行集成 （3）spring-webmvc-portlet （即Web-Portlet模块）提供了用于 Portlet 环境的 MVC 实现，并反映了 pring-webmvc 模块的功能 4、AOP （1）spring-aop 提供了面向切面编程（AOP）的实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦。使用源码级的元数据。 （2）spring-aspects 提供了对 AspectJ 的集成 5、Instrumentation （1）spring-instrument 模块提供了对检测类的支持和用于特定的应用服务器的类加载器的实现。 （2）spring-instrument-tomcat 模块包含了用于 Tomcat 的Spring 检测代理。 6、Messaging - 消息处理 spring-messaging 模块 从 Spring 4 开始集成，从一些 Spring 集成项目的关键抽象中提取出来的。这些项目包括 Message、MessageChannel、MessageHandler 和其它服务于消息处理的项目。这个模块也包含一系列的注解用于映射消息到方法 7、Test spring-test 模块 通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object） 六、入门程序和IOC1、下载 Spring框架的主页：http://spring.io/ 下载地址：http://repo.spring.io/release/org/springframework/spring 2、创建项目 spring-01-IOC java项目或maven项目 3、引入jar包 核心包加日志包 12345678910111213pom:&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 4、引入log4j.properties 放入源码目录（maven项目放在src/mian/resources下） 5、创建一个类 12345678910package name.yaohuan.spring.bean;public class Person &#123; private String name; private Integer age; public Person() &#123; super(); System.out.println(&quot;Person的空参构造方法&quot;); &#125; //getter、setter、空参构造、toString&#125; 6、创建配置文件 配置文件的位置和名字可以自定义，但是建议放在src下，名字为applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 也可以安装spring的sts插件 7、配置bean对象 在配置文件中添加bean的配置，让spring管理对象的创建 1&lt;bean name=&quot;person&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 说明： bean元素：素描述需要spring容器管理的对象。 class属性：被管理对象的完整类名。 name属性：给被管理的对象起个名字，根据该名称获得对象。 8、测试 12345678910111213141516package name.yaohuan.spring.bean;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class IOCTest &#123; @Test public void testCreatePerson()&#123; //1、创建容器对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //2、在容器中找到person对象 Person p = (Person)context.getBean(&quot;person&quot;); //3、打印 System.out.println(p); &#125;&#125; 七、什么是IoCIoC-控制反转 IoC是 Inverse of Control 的简写，意思是控制反转。是降低对象之间的耦合关系的设计思想。 通过IOC，开发人员不需要关心对象的创建过程，交给Spring容器完成。具体的过程是，程序读取Spring 配置文件，获取需要创建的 bean 对象， 通过反射机制创建对象的实例。 缺点：对象是通过反射机制实例化出来的，因此对系统的性能有一定的影响。 DI-依赖注入 Dependency Injection，说的是创建对象实例时，同时为这个对象注入它所依赖的属性。相当于把每个bean与bean之间的关系交给容器管理。而这个容器就是spring。 例如我们通常在 Service 层注入它所依赖的 Dao 层的实例；在 Controller层注入 Service层的实例。 IoC和DI IoC的别名,2004年，Martin Fowler探讨了同一个问题，既然IoC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理对象变为由IoC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection，DI）”。他的这个答案，实际上给出了实现IoC的方法：注入。 所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。 所以，依赖注入（DI）和控制反转（IoC）是从不同的角度描述的同一件事情，就是指通过引入IoC容器，利用依赖关系注入的方式，实现对象之间的解耦 八、对象创建的细节applicationContext-bean.xml BeanTest.java 一、bean元素的id和name bean元素既可以定义name属性，也可以定义id属性 name属性：可以重复，可以使用特殊字符。id属性：作用与name属性一样。名称不可重复，不能使用特殊字符。 1&lt;bean id=&quot;person1&quot; name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 以下两种方式都可以获取到上面的Person对象 123456@Test public void testCreatePerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); Person p1 = (Person)context.getBean(&quot;person1&quot;);//方式1 Person p2= (Person)context.getBean(&quot;person2&quot;);//方式2 &#125; 二、创建对象的工厂 1、FileSystemXmlApplicationContext：从硬盘绝对路径下加载配置文件 1234@Testpublic void testBeanFactory1()&#123; ApplicationContext context = new FileSystemXmlApplicationContext(&quot;D:\\\\workspace\\\\spring-01-IOC\\\\src\\\\applicationContext-bean.xml&quot;);&#125; 2、ClassPathXmlApplicationContext：丛类路径下加载配置文件 1234@Test public void testBeanFactory2()&#123; ApplicationContext context2 = new ClassPathXmlApplicationContext(&quot;applicationContextbean-bean.xml&quot;); &#125; 通过上面的测试也可以发现，默认情况下，每次容器启动时就会创建容器中配置的所有对象 三、单例和多例 为bean配置scope属性 1、scope=”singleton”，单例， 默认值， 适用实际开发中的绝大部分情况 1&lt;bean name=&quot;person&quot; scope=&quot;singleton&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 1234567@Test public void testScope()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); Person p1 = (Person)context.getBean(&quot;person&quot;); Person p2 = (Person)context.getBean(&quot;person&quot;); System.out.println(p1==p2); //true &#125; 2、scope=”prototype”，多例，适用于struts2中的action的配置 1&lt;bean name=&quot;person&quot; scope=&quot;prototype&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 1234567@Test public void testScope()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); Person p1 = (Person)context.getBean(&quot;person&quot;); Person p2 = (Person)context.getBean(&quot;person&quot;); System.out.println(p1==p2); //false &#125; 3、scope=“request”（了解）：web环境下，对象与request生命周期一致。很少用。 4、scope=“session”（了解）：web环境下，对象与session生命周期一致。很少用。 四、对象创建的时机 scope=”singleton” 在启动容器时， 创建bean，且整个应用只有一个。 scope=”prototype” 在用到对象的时候，才创建对象。每次创建都是新的对象。 五、是否延迟创建 注意：只对单例有效，设置scope=”singleton”时测试 lazy-init=”false” 默认值，不延迟创建，即在启动时候就创建对象 lazy-init=”true” 延迟初始化， 在用到对象的时候才创建对象 1&lt;bean name=&quot;person&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 123456@Test public void testLazy()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); //lazy-init=&quot;true&quot;，则直到执行下面的语句对象才会被创建 Person p = (Person)context.getBean(&quot;person&quot;); &#125; 六、初始化/销毁 init-method=”init” 对应对象的init()方法，在对象创建之后执行 destroy-method=”destroy” 调用容器对象的destroy()方法时候执行 在Person类中添加初始化方法和销毁方法： 1234567public void init() &#123; System.out.println(&quot;Person的初始化方法&quot;); &#125; public void destroy() &#123; System.out.println(&quot;Person的销毁方法&quot;); &#125; 配置bean： 1&lt;bean name=&quot;person&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 测试： 注意：单实例时测试 123456789@Test public void testInitAndDestroy()&#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); //或者手动调用销毁方法 context.destroy(); //或者关闭容器，触发销毁方法 //context.close(); &#125; 九、对象创建的几种方式applicationContext-create.xml CreateTest.java 一、无参构造函数 前面的方式调用了类的无参构造函数 二、有参构造函数 参考后面章节的：对象的依赖-属性注入（构造函数注入） 三、静态工厂方法 创建工厂类： 12345678package name.yaohuan.spring.factory;import name.yaohuan.spring.bean.Person;public class PersonFactory &#123; public static Person createPerson1()&#123; System.out.println(&quot;静态工厂创建Person&quot;); return new Person(); &#125;&#125; 配置bean： 12&lt;!-- 静态工厂创建 --&gt;&lt;bean name=&quot;person1&quot; class=&quot;name.yaohuan.spring.factory.PersonFactory&quot; factory-method=&quot;createPerson1&quot;&gt;&lt;/bean&gt; 测试： 容器初始化的时候同时调用静态工厂初始化了对象 1234@Test public void testCreatePerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-create.xml&quot;); &#125; 四、实例工厂 在上一步的工厂类中添加实例工厂方法： 1234public Person createPerson2()&#123; System.out.println(&quot;实例工厂创建Person&quot;); return new Person();&#125; 配置bean： 123&lt;!-- 实例工厂创建 --&gt;&lt;bean name=&quot;personFactory&quot; class=&quot;name.yaohuan.spring.factory.PersonFactory&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;person2&quot; factory-bean=&quot;personFactory&quot; factory-method=&quot;createPerson2&quot;&gt;&lt;/bean&gt; 测试： 使用上一步的测试用例即可 十、对象的依赖关系-依赖注入applicationContext-injection.xmlInjectionTest.java 一、set方法注入 1、值类型注入使用 value 配置bean： 12345&lt;!-- set注入 --&gt;&lt;bean name=&quot;person1&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;helen&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 1234567@Test public void testProperty()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person1&quot;); System.out.println(p); &#125; 在Person中添加 toString() 方法 结果： 2、引用类型注入使用 ref 创建Car.java： 1234567891011package name.yaohuan.spring.bean;public class Car &#123; private String name; private String color; public Car() &#123; super(); System.out.println(&quot;Car的空参构造方法&quot;); &#125; //getter、setter、toString&#125; 在Person中引用Car： 123456public class Person &#123; private String name; private Integer age; private Car car; //getter、setter、toString等&#125; 配置bean： 12345678910&lt;bean name=&quot;person1&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;helen&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name=&quot;car&quot; class=&quot;name.yaohuan.spring.bean.Car&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;MINI&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;灰色&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 测试： 1234567@Test public void testProperty()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person1&quot;); System.out.println(p); &#125; 测试：使用上一步的测试用例即可 二、构造函数注入 1、name属性：按参数名注入 在Person中创建构造函数： 123456public Person(String name, Car car) &#123; super(); System.out.println(&quot;Person(String name, Car car)&quot;); this.name = name; this.car = car; &#125; 配置bean：使用 name 属性指定参数名 1234&lt;bean name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;helen&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 测试： 123456@Test public void testConstuctor()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person2&quot;); System.out.println(p); &#125; 结果： 2、index属性：按参数索引注入 参数名一致，但位置不一致时，使用 index 例如以下两个构造函数： 12345678910111213public Person(String name, Car car) &#123; super(); System.out.println(&quot;Person(String name, Car car)&quot;); this.name = name; this.car = car; &#125; public Person(Car car, String name) &#123; super(); System.out.println(&quot;Person(Car car, String name)&quot;); this.name = name; this.car = car; &#125; 配置bean，使用index确定调用哪个构造函数： 1234&lt;bean name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;helen&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 重新执行第一步的测试用例 结果： 3、type属性：按参数类型注入 参数名和位置一致，但类型不一致时，使用type 例如以下两个构造函数： 12345678910111213public Person(Car car, String name) &#123; super(); System.out.println(&quot;Person(Car car, String name)&quot;); this.name = name; this.car = car; &#125; public Person(Car car, Integer name) &#123; super(); System.out.println(&quot;Person(Car car, Integer name)&quot;); this.name = name + &quot;&quot;; this.car = car; &#125; 配置bean，使用type指定参数的类型 1234&lt;bean name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;988&quot; type=&quot;java.lang.Integer&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; &gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 重新执行第一步的测试用例 结果： 三、p名称空间注入 导入p名称空间 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 使用 p:属性名 完成注入，走set方法 值类型：p:属性名=”值” 对象类型：p:属性名-ref=”bean名称” 12&lt;bean name=&quot;person3&quot; class=&quot;name.yaohuan.spring.bean.Person&quot; p:name=&quot;helen&quot; p:age=&quot;18&quot; p:car-ref=&quot;car&quot;&gt;&lt;/bean&gt; 测试： 123456@Test public void testP()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person3&quot;); System.out.println(p); &#125; 结果： 四、spel注入 spring Expression Language：spring表达式语言 bean配置 12345&lt;bean name=&quot;person4&quot; class=&quot;name.yaohuan.spring.bean.Person&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;person1.name&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;#&#123;person1.age&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 测试： 123456@Test public void testSpel()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person4&quot;); System.out.println(p); &#125; 结果： 十一、对象的依赖关系-复杂类型注入applicationContext-collection.xml CollectionTest.java 实体类： 123456789101112package name.yaohuan.spring.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Properties;public class CollectionBean &#123; private Object[] arr;//数组类型注入 private List list;//list/set 类型注入 private Map map;//map类型注入 private Properties prop;//properties类型注入 //getter、setter、空参构造、toString&#125; 一、数组注入 1、如果数组中只准备注入一个 值 | 对象，直接使用 value | ref 即可 1234567891011&lt;bean name=&quot;car&quot; class=&quot;name.yaohuan.spring.bean.Car&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;MINI&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;灰色&quot; &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 数组注入 --&gt; &lt;bean name=&quot;cb1&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;!-- 如果数组中只准备注入一个值(对象)，直接使用value|ref即可 --&gt; &lt;property name=&quot;arr&quot; value=&quot;helen&quot; &gt;&lt;/property&gt; &lt;!-- &lt;property name=&quot;arr&quot; ref=&quot;car&quot; &gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 2、多个数组元素 12345678910&lt;bean name=&quot;cb2&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;!-- array注入,多个元素注入 --&gt; &lt;property name=&quot;arr&quot;&gt; &lt;array&gt; &lt;value&gt;tom&lt;/value&gt; &lt;value&gt;helen&lt;/value&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 二、List注入 1、如果集合中只准备注入一个值(对象),直接使用value|ref即可 1234&lt;bean name=&quot;cb3&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;!-- 如果List中只准备注入一个值(对象),直接使用value|ref即可 --&gt; &lt;property name=&quot;list&quot; value=&quot;helen&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 2、多个集合元素 123456789&lt;bean name=&quot;cb4&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;helen&lt;/value&gt; &lt;value&gt;rose&lt;/value&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 三、Map注入 123456789&lt;bean name=&quot;cb5&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;username&quot; value=&quot;root&quot; &gt;&lt;/entry&gt; &lt;entry key=&quot;car&quot; value-ref=&quot;car&quot; &gt;&lt;/entry&gt; &lt;entry key-ref=&quot;car&quot; value-ref=&quot;car&quot; &gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 四、properties类型注入 123456789&lt;bean name=&quot;cb6&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;property name=&quot;prop&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverClass&quot;&gt;com.jdbc.mysql.Driver&lt;/prop&gt; &lt;prop key=&quot;userName&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 十二、使用注解1、创建项目 spring-02-annotation 2、引入jar包 核心包加日志包（和之前一样） 加 spring-aop 包 maven项目无需添加新包，context依赖了aop。完整的依赖如下： 123456789101112&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、创建实体类 Person.java：保留基本空参构造方法和getter、setter即可 Car.java 5、创建applicationContext.xml 引入新的名称空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;&lt;/beans&gt; 6、配置注解扫描 指定扫描name.yaohuan.spring.bean下的所有类中的注解。 扫描包时，会扫描所有子孙包 1&lt;context:component-scan base-package=&quot;name.yaohuan.spring.bean&quot;&gt;&lt;/context:component-scan&gt; 7、在类中使用注解 123@Component(&quot;person&quot;)//&lt;bean name=&quot;person&quot; class=&quot;name.yaohuan.spring.bean.Person&quot; /&gt;public class Person &#123; 8、测试 123456789public class AnnotationTest &#123; @Test public void testCreatePerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person p = (Person)context.getBean(&quot;person&quot;); System.out.println(p); &#125; &#125; 9、其他类的头部可用的注解 123@Service(&quot;person&quot;) // service层@Controller(&quot;person&quot;) // controller层@Repository(&quot;person&quot;)// dao层 10、在类的头部指定对象的作用域 12@Scope(scopeName=&quot;singleton&quot;)@Scope(scopeName=&quot;prototype&quot;) 11、注入属性value值 加在成员变量上：通过反射的Field赋值（破坏对象的封装性） 12@Value(&quot;helen&quot;) private String name; 或加在set方法上：通过set方法赋值 1234@Value(&quot;tom&quot;) public void setName(String name) &#123; this.name = name; &#125; @Value(“helen”) 等同于 @Value(value=”helen”) 12、自动装配 （1）@Autowired 1234567@Component(&quot;car&quot;)public class Car &#123; @Value(&quot;mini&quot;) private String name; @Value(&quot;红&quot;) private String color;&#125; 123456789@Component(&quot;person&quot;)public class Person &#123; @Value(&quot;helen&quot;) private String name; @Value(&quot;18&quot;) private Integer age; @Autowired private Car car;&#125; （2）@Qualifier 如果匹配多个类型一致的对象，将无法选择具体注入哪一个对象 使用@Qualifier()注解告诉spring容器自动装配哪个名称的对象 创建Computer接口和PC、Labtop实现类： 12public interface Computer &#123;&#125; 123456@Component(&quot;pc&quot;)public class PC implements Computer&#123; @Value(&quot;联想台式机&quot;) private String name; //getter、setter、空参构造、toString&#125; 123456@Component(&quot;labtop&quot;)public class Labtop implements Computer&#123; @Value(&quot;苹果笔记本&quot;) private String name; //getter、setter、空参构造、toString&#125; 在Person类中添加Computer属性：使用 @Qualifier(&quot;labtop&quot;) 指定装配 @Component(&quot;labtop&quot;) 对象 1234@Autowired @Qualifier(&quot;labtop&quot;) private Computer computer; //getter、setter （3）@Resource 使用@Resource指定注入哪个名称的对象 12@Resource(name=&quot;pc&quot;) private Computer computer; 13、初始化和销毁方法 注意：单实例时设置 person类： 123456789@PostConstruct //在对象被创建后调用，init-method public void init() &#123; System.out.println(&quot;Person的初始化方法&quot;); &#125; @PreDestroy //在销毁之前调用，destory-method public void destroy() &#123; System.out.println(&quot;Person的销毁方法&quot;); &#125; 测试： 12345678@Test public void testInitAndDestroy()&#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //或者手动调用销毁方法 context.destroy(); //或者关闭容器，触发销毁方法 //context.close(); &#125; 十三、spring整合junit测试spring整合junit，为我们提供了方便的测试方式 1、导包 在spring-02-annotation项目中再加入如下包 pom： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 完整的依赖如下： 1234567891011121314151617&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2、创建测试类 12345678910111213//创建容器@RunWith(SpringJUnit4ClassRunner.class)//指定创建容器时使用哪个配置文件@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class RunWithTest &#123; //将名为user的对象注入到u变量中 @Resource(name=&quot;person&quot;) private Person p; @Test public void testCreatePerson()&#123; System.out.println(p); &#125;&#125; 十四、aop简介1、AOP （面向切面编程） 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP 思想：横向重复、纵向抽取 2、底层实现： Spring 的 AOP 的底层用到两种代理机制： JDK 的动态代理：针对实现了接口的类产生代理。 Cglib 的动态代理：针对没有实现接口的类产生代理，应用的是底层的字节码增强的技术 生成当前类的子类对象。 3、AOP 的开发中的相关术语： Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在 spring 中，这些点指的是方法,因为 spring 只支持方法类型的连接点（可以被切入的点） Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。（已经被切入的点） Advice（通知/增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能） Introduction（引介）：引介是一种特殊的通知在不修改类代码的前提下，Introduction 可以在运行期为类动态地添加一些方法或 Field。 Aspect（切面）：是切入点和通知（引介）的结合 Target（目标对象）：代理的目标对象 Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。 Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 十五、spring aop 开发（xml）1、创建项目 spring-03-aop 2、引入jar包 核心包加日志包（和之前一样） 测试包 再加入以下包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 完整的依赖如下： 12345678910111213141516171819202122&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、准备目标对象 先创建UserService接口： 1234567package name.yaohuan.spring.service;public interface UserService &#123; void save(); void delete(); void update(); void select();&#125; 实现类： 123456789101112131415161718192021222324package name.yaohuan.spring.service;public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(&quot;保存用户!&quot;); //int i = 1/0; &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户!&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新用户!&quot;); &#125; @Override public void select() &#123; System.out.println(&quot;查找用户!&quot;); &#125;&#125; 5、准备通知 123456789101112131415161718192021222324252627282930313233343536package name.yaohuan.spring.aop;import org.aspectj.lang.ProceedingJoinPoint;//通知类public class MyAdvice &#123; //前置通知：目标方法运行之前调用 //后置通知(如果出现异常不会调用)：在目标方法运行之后调用 //环绕通知：在目标方法之前和之后都调用 //异常拦截通知：如果出现异常，就会调用 //后置通知(无论是否出现 异常都会调用)：在目标方法运行之后调用 //前置通知 public void before()&#123; System.out.println(&quot;这是前置通知!!&quot;); &#125; //后置通知 public void afterReturning()&#123; System.out.println(&quot;这是后置通知(如果出现异常不会调用)!!&quot;); &#125; //环绕通知 public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;这是环绕通知之前的部分!!&quot;); Object proceed = pjp.proceed();//调用目标方法 System.out.println(&quot;这是环绕通知之后的部分!!&quot;); return proceed; &#125; //异常通知 public void afterException()&#123; System.out.println(&quot;出事啦!出现异常了!!&quot;); &#125; //后置通知 public void after()&#123; System.out.println(&quot;这是后置通知(出现异常也会调用)!!&quot;); &#125;&#125; 6、配置进行织入,将通知织入目标对象中 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;&gt;&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt; &lt;bean name=&quot;userService&quot; class=&quot;name.yaohuan.spring.service.UserServiceImpl&quot; &gt;&lt;/bean&gt;&lt;!-- 2.配置通知对象 --&gt; &lt;bean name=&quot;myAdvice&quot; class=&quot;name.yaohuan.spring.aop.MyAdvice&quot; &gt;&lt;/bean&gt;&lt;!-- 3.配置将通知织入目标对象 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点 public void name.yaohuan.spring.service.UserServiceImpl.save() * name.yaohuan.spring.service.UserServiceImpl.*() * name.yaohuan.spring.service.*ServiceImpl.*(..) * name.yaohuan.spring.service..*ServiceImpl.*(..) --&gt; &lt;aop:pointcut expression=&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot; id=&quot;pc&quot;/&gt; &lt;aop:aspect ref=&quot;myAdvice&quot; &gt; &lt;!-- 指定名为before方法作为前置通知 --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pc&quot; /&gt; &lt;!-- 后置 --&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pc&quot; /&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pc&quot; /&gt; &lt;!-- 异常拦截通知 --&gt; &lt;aop:after-throwing method=&quot;afterException&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;!-- 后置 --&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 7、测试 123456789101112131415161718package name.yaohuan.spring.service;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Resource(name=&quot;userService&quot;) private UserService userService; @Test public void testSave()&#123; userService.save(); &#125;&#125; 十六、spring aop 开发（注解）1、按照前面的步骤中准备目标对象和通知 2、配置文件 配置目标对象 配置通知对象 开启注解 12&lt;!-- 3.开启使用注解完成织入 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 7、MyAdvice中加注解 123456789101112131415161718192021222324252627282930313233343536//通知类@Aspect//表示该类是一个通知类public class MyAdvice &#123; @Pointcut(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void pc()&#123;&#125; //前置通知 //指定该方法是前置通知,并制定切入点 @Before(&quot;MyAdvice.pc()&quot;) public void before()&#123; System.out.println(&quot;这是前置通知!!&quot;); &#125; //后置通知 @AfterReturning(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void afterReturning()&#123; System.out.println(&quot;这是后置通知(如果出现异常不会调用)!!&quot;); &#125; //环绕通知 @Around(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;这是环绕通知之前的部分!!&quot;); Object proceed = pjp.proceed();//调用目标方法 System.out.println(&quot;这是环绕通知之后的部分!!&quot;); return proceed; &#125; //异常通知 @AfterThrowing(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void afterException()&#123; System.out.println(&quot;出事啦!出现异常了!!&quot;); &#125; //后置通知 @After(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;这是后置通知(出现异常也会调用)!!&quot;); &#125;&#125; 十七、JdbcTemplate入门类似DBUtils 的 QueryRunner 案例：救援系统的角色表的增删改查 1、创建项目 spring-04-jdbcTemplate 2、导包 核心包加日志包（和之前一样） 测试包 再加入以下jar包 完整的依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、数据库 新建数据库spring，创建角色表 12345678910111213/*Table structure for table `ar_role` */CREATE TABLE `ar_role` ( `rid` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;角色id&apos;, `rname` varchar(20) NOT NULL COMMENT &apos;角色名&apos;, `alias` varchar(20) NOT NULL COMMENT &apos;角色别名&apos;, PRIMARY KEY (`rid`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;/*Data for the table `ar_role` */insert into `ar_role`(`rid`,`rname`,`alias`) values (1,&apos;administrator&apos;,&apos;系统管理员&apos;);insert into `ar_role`(`rid`,`rname`,`alias`) values (2,&apos;dispatcher&apos;,&apos;调度员&apos;); 5、拷贝之前写的 DataSourceUtil.java 6、拷贝c3p0-config.xml 7、写测试类 下面是不使用 DataSourceUtil.java 的版本，和使用 DataSourceUtil.java 的版本 12345678910111213141516171819202122232425262728293031323334353637383940package name.yaohuan.spring.jdbctemplate;public class JdbcTemplateTest &#123; //不使用工具类 @Test public void testSave1() throws PropertyVetoException&#123; //准备连接池 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/spring&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); //创建JdbcTemplate对象 JdbcTemplate jt= new JdbcTemplate(dataSource); //执行sql String sql = &quot; INSERT INTO ar_role ( &quot; + &quot; rname,&quot; + &quot; alias&quot; + &quot; ) VALUES (?,?)&quot; ; jt.update(sql, &quot;test1&quot;, &quot;test1&quot;); &#125; //使用工具类 @Test public void testSave2() throws PropertyVetoException&#123; //准备连接池 DataSource dataSource = DataSourceUtil.getDataSource(); //创建JdbcTemplate对象 JdbcTemplate jt= new JdbcTemplate(dataSource); //执行sql String sql = &quot; INSERT INTO ar_role ( &quot; + &quot; rname,&quot; + &quot; alias&quot; + &quot; ) VALUES (?,?)&quot; ; jt.update(sql, &quot;test2&quot;, &quot;test2&quot;); &#125;&#125; 十八、用spring管理JdbcTemplate学习JdbcTemplate API 和 如何用Spring 管理 JdbcTemplate 1、创建 pojo.Role.java 123456package name.yaohuan.spring.pojo;public class Role &#123; private Integer rid; private String rname; private String alias;&#125; 2、创建 dao.RoleDao.java 和 dao.RoleDaoImpl.java 123456789101112131415package name.yaohuan.spring.dao;public interface RoleDao &#123; //增 void save(Role role); //删 void delete(Integer id); //改 void update(Role role); //查 Role getById(Integer id); //查 int getTotalCount(); //查 List&lt;Role&gt; getAll();&#125; 将数据源（连接池）、JdbcTemplate、RoleDao对象交给spring容器管理 如果不用注解的方式配置，不要忘记写jt的 set 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package name.yaohuan.spring.dao;public class RoleDaoImpl extends JdbcDaoSupport implements RoleDao &#123; private JdbcTemplate jt; public void setJt(JdbcTemplate jt) &#123; this.jt = jt; &#125; @Override public void save(Role role) &#123; String sql = &quot; INSERT INTO ar_role ( &quot; + &quot; rname,&quot; + &quot; alias&quot; + &quot; ) VALUES (?,?)&quot; ; jt.update(sql, role.getRname(), role.getAlias()); &#125; @Override public void delete(Integer id) &#123; String sql = &quot;delete from ar_role where rid = ? &quot;; jt.update(sql, id); &#125; @Override public void update(Role role) &#123; String sql = &quot;update ar_role set rname = ?, alias = ? where rid=? &quot;; jt.update(sql, role.getRname(), role.getAlias(), role.getRid()); &#125; @Override public Role getById(Integer id) &#123; String sql = &quot;select * from ar_role where rid = ? &quot;; return jt.queryForObject(sql,new RowMapper&lt;Role&gt;()&#123; @Override public Role mapRow(ResultSet rs, int index) throws SQLException &#123; return mapRowHandler(rs); &#125;&#125;, id); &#125; @Override public int getTotalCount() &#123; String sql = &quot;select count(*) from ar_role &quot;; Integer count = jt.queryForObject(sql, Integer.class); return count; &#125; @Override public List&lt;Role&gt; getAll() &#123; String sql = &quot;select * from ar_role&quot;; List&lt;Role&gt; list = jt.query(sql, new RowMapper&lt;Role&gt;()&#123; @Override public Role mapRow(ResultSet rs, int index) throws SQLException &#123; return mapRowHandler(rs); &#125;&#125;); return list; &#125; private Role mapRowHandler(ResultSet rs) throws SQLException &#123; Role role = new Role(); role.setRname(rs.getString(&quot;rname&quot;)); role.setAlias(rs.getString(&quot;alias&quot;)); role.setRid(rs.getInt(&quot;rid&quot;)); return role; &#125;&#125; 3、创建db.properties 1234jdbc.jdbcUrl=jdbc:mysql://localhost:3306/springjdbc.driverClass=com.mysql.jdbc.Driverjdbc.user=rootjdbc.password=123456 4、配置applicationContext.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 1、连接池 --&gt;&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; &gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2、JdbcTemplate --&gt;&lt;bean name=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、roleDao --&gt;&lt;bean name=&quot;roleDao&quot; class=&quot;name.yaohuan.spring.dao.RoleDaoImpl&quot; &gt; &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplate&quot; &gt;&lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt; 5、写测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package name.yaohuan.spring.jdbctemplate;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class SpringJdbcTemplateTest &#123; @Resource(name=&quot;roleDao&quot;) private RoleDao roleDao; @Test public void testSave() throws Exception&#123; Role role = new Role(); role.setRname(&quot;spring1&quot;); role.setAlias(&quot;spring1&quot;); roleDao.save(role); &#125; @Test public void testDelete() throws Exception&#123; roleDao.delete(11); &#125; @Test public void testUpdate() throws Exception&#123; Role role = new Role(); role.setRid(10); role.setRname(&quot;spring123&quot;); role.setAlias(&quot;spring123&quot;); roleDao.update(role); &#125; @Test public void testGetById() throws Exception&#123; System.out.println(roleDao.getById(1)); &#125; @Test public void testGetTotalCount() throws Exception&#123; System.out.println(roleDao.getTotalCount()); &#125; @Test public void testGetAll() throws Exception&#123; System.out.println(roleDao.getAll()); &#125;&#125; 6、也可以使用注解的方式 （1）在applicationContext中配置注解扫描 1&lt;context:component-scan base-package=&quot;name.yaohuan.spring.dao&quot;&gt;&lt;/context:component-scan&gt; （2）不用配置 &lt;bean name=”roleDao” … （3）在 RoleDaoImpl中配置注解 此时已经不需要 jt 的 set 方法 12345@Repository(&quot;roleDao&quot;)public class RoleDaoImpl implements RoleDao &#123; @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jt; （4）执行刚才的测试用例即可 十九、转账的案例（无事务）案例：转账 1、创建项目 spring-05-tx 2、导包 同 前一个项目 spring-04-jdbcTemplate，再加上aop的相关包 完整的依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、复制数据库配置 db.properties 5、创建数据库表 在spring数据库中创建 12345678910111213/*Table structure for table `ar_account` */CREATE TABLE `ar_account` ( `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `username` VARCHAR(20) NOT NULL, `money` DECIMAL(10,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;/*Data for the table `ar_account` */INSERT INTO `ar_account`(`id`,`username`,`money`) VALUES (1,&apos;Helen&apos;,&apos;1000.00&apos;);INSERT INTO `ar_account`(`id`,`username`,`money`) VALUES (2,&apos;Tom&apos;,&apos;1000.00&apos;); 6、创建dao接口和dao 1234567package name.yaohuan.spring.dao;public interface AccountDao &#123; //加钱 void increaseMoney(Integer id,Double money); //减钱 void decreaseMoney(Integer id,Double money);&#125; 123456789101112131415package name.yaohuan.spring.dao;@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jt; @Override public void increaseMoney(Integer id, Double money) &#123; jt.update(&quot;update ar_account set money = money+? where id = ? &quot;, money,id); &#125; @Override public void decreaseMoney(Integer id, Double money) &#123; jt.update(&quot;update ar_account set money = money-? where id = ? &quot;, money,id); &#125;&#125; 7、创建service接口和service 12345package name.yaohuan.spring.service;public interface AccountService &#123; //转账方法 void transfer(Integer from, Integer to, Double money);&#125; 123456789101112131415package name.yaohuan.spring.service;@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Resource(name=&quot;accountDao&quot;) private AccountDao accountDao ; @Override public void transfer(final Integer from,final Integer to,final Double money) &#123; //减钱 accountDao.decreaseMoney(from, money); int i = 1/0; //异常 //加钱 accountDao.increaseMoney(to, money); &#125;&#125; 8、创建applicationContext.xml 先不加入事务处理 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;&lt;!-- 注解扫描 --&gt;&lt;context:component-scan base-package=&quot;name.yaohuan.spring.dao&quot;&gt;&lt;/context:component-scan&gt;&lt;context:component-scan base-package=&quot;name.yaohuan.spring.service&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 1、连接池 --&gt;&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; &gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2、JdbcTemplate --&gt;&lt;bean name=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 9、创建测试 123456789101112package name.yaohuan.spring.service;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class TxTest &#123; @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void testTransfer()&#123; accountService.transfer(1, 2, 100d); &#125;&#125; 二十、复习事务相关概念一、什么是事务(Transaction) 是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。通过事务，sql 能将逻辑相关的一组操作绑定在一起，以便服务器 保持数据的完整性。事务通常是以begin transaction开始，以commit或rollback结束。Commint表示提交，即提交事务的所有操作。具体地说就是将事务中所有对数据的更新写回到磁盘上的物理数据库中去，事务正常结束。Rollback表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态。 设想网上购物的一次交易，其付款过程至少包括以下几步数据库操作： 1、更新客户所购商品的库存信息 2、保存客户付款信息–可能包括与银行系统的交互 3、生成订单并且保存到数据库中 4、更新用户相关信息，例如购物数量等等 正常的情况下，这些操作将顺利进行，最终交易成功，与交易相关的所有数据库信息也成功地更新。但是，如果在这一系列过程中任何一个环节出了差错，例如在更新商品库存信息时发生异常、该顾客银行帐户存款不足等，都将导致交易失败。一旦交易失败，数据库中所有信息都必须保持交易前的状态不变，比如最后一步更新用户信息时失败而导致交易失败，那么必须保证这笔失败的交易不影响数据库的状态–库存信息没有被更新、用户也没有付款，订单也没有生成。否则，数据库的信息将会一片混乱而不可预测。 数据库事务正是用来保证这种情况下交易的平稳性和可预测性的技术 二、为什么要使用事务？ 1、为了提高性能 2、为了保持业务流程的完整性 3、使用分布式事务 三、事务的特性 ACID 1、原子性（atomicity） 事务是数据库的逻辑工作单位，而且是必须是原子工作单位，对于其数据修改，要么全部执行，要么全部不执行。 2、一致性（consistency） 事务在完成时，必须是所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。 3、隔离性（isolation） 一个事务的执行不能被其他事务所影响。企业级的数据库每一秒钟都可能应付成千上万的并发访问，因而带来了并发控制的问题。由数据库理论可知，由于并发访问，在不可预料的时刻可能引发如下几个可以预料的问题：（见“二、事务的并发问题“） 4、持久性（durability） 一个事务一旦提交，事物的操作便永久性的保存在DB中。即使此时再执行回滚操作也不能撤消所做的更改 四、事务的并发问题 1、脏读（Dirty Read） 一个事务读取到了另一个事务未提交的数据操作结果。这是相当危险的，因为很可能所有的操作都被回滚。 2、不可重复读（虚读）（NonRepeatable Read） 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。 3、幻读（Phantom Read） 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据，这是因为在两次查询过程中有另外一个事务插入数据造成的 五、事务的隔离级别 1 - 读未提交 Read uncommitted：最低级别，以上情况均无法保证。 2 - 读已提交 Read committed：可避免脏读情况发生。（Oracle默认） 4 - 可重复读 Repeatable read：可避免脏读、不可重复读情况的发生。不可以避免虚读。（MySQl默认） 8 - 串行化读Serializable：事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重。 二十一、spring的事务管理接口1、Spring 的 TransactionManager 接口： 在不同平台，操作事务的代码各不相同，因此spring提供了一个 TransactionManager 接口： DateSourceTransactionManager 用于 JDBC 的事务管理 HibernateTransactionManager 用于 Hibernate 的事务管理 JpaTransactionManager 用于 Jpa 的事务管理 2、Spring中 TransactionManager 接口的定义（源码） 事务的属性介绍：这里定义了传播行为、隔离级别、超时时间、是否只读 绝大部分场景下会使用 PROPAGATION_REQUIRED 和 PROPAGATION_SUPPORTS 12345678910111213141516171819202122232425262728package org.springframework.transaction;public interface TransactionDefinition &#123; int PROPAGATION_REQUIRED = 0; //支持当前事务，如果不存在，就新建一个 int PROPAGATION_SUPPORTS = 1; //支持当前事务，如果不存在，就不使用事务 int PROPAGATION_MANDATORY = 2; //支持当前事务，如果不存在，就抛出异常 int PROPAGATION_REQUIRES_NEW = 3;//如果有事务存在，挂起当前事务，创建一个新的事物 int PROPAGATION_NOT_SUPPORTED = 4;//以非事务方式运行，如果有事务存在，挂起当前事务 int PROPAGATION_NEVER = 5;//以非事务方式运行，如果有事务存在，就抛出异常 int PROPAGATION_NESTED = 6;//如果有事务存在，则嵌套事务执行 int ISOLATION_DEFAULT = -1;//默认级别，MYSQL: 默认为REPEATABLE_READ级别 SQLSERVER: 默认为READ_COMMITTED int ISOLATION_READ_UNCOMMITTED = 1;//读取未提交数据(会出现脏读, 不可重复读) 基本不使用 int ISOLATION_READ_COMMITTED = 2;//读取已提交数据(会出现不可重复读和幻读) int ISOLATION_REPEATABLE_READ = 4;//可重复读(会出现幻读) int ISOLATION_SERIALIZABLE = 8;//串行化 int TIMEOUT_DEFAULT = -1;//默认是-1，不超时，单位是秒 //事务的传播行为 int getPropagationBehavior(); //事务的隔离级别 int getIsolationLevel(); //事务超时时间 int getTimeout(); //是否只读 boolean isReadOnly(); String getName();&#125; 二十二、xml事务管理1、在applicationContext.xml中添加 tx 名称空间 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;&lt;/beans&gt; 2、在applicationContext.xml中添加事务相关配置 12345678910111213141516171819202122232425262728293031&lt;!-- 事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 通知 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;!-- REQUIRED：如果有事务，则在事务中执行；如果没有事务，则开启一个新的事物 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;!-- SUPPORTS：如果有事务，则在事务中执行；如果没有事务，则不会开启事物 --&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 切面 --&gt;&lt;aop:config&gt; &lt;!-- 定义在service包或者子包里的任意方法的执行 --&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* name.yaohuan.spring.service..*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot; /&gt;&lt;/aop:config&gt; 自定义aop和spring事物的执行顺序分析 1、如果先配置spring的事物，后配置自定义的aop，那么事物会在自定义aop通知后提交 2、如果后配置spring的事物，先配置自定义的aop，那么事物会在自定义aop通知前提交 二十三、注解事务管理1、修改 applicationContext.xml 在 applicationContext.xml 中添加开启注解事务的配置，删除通知和切面的配置，保留事务管理器的配置 12345678&lt;!-- 事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 开启使用注解管理aop事务 --&gt;&lt;tx:annotation-driven/&gt; 2、在service层的每个方法上添加事务的配置 123@Override @Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false) public void transfer(final Integer from,final Integer to,final Double money) &#123; 也可以在类名上方定义 @Transactional 或配置通用属性，统一定义所有的service方法。如果有方法采用不同的配置，则在方法名上方单独配置","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zymmx.github.io/tags/Spring/"}]},{"title":"hexo + github 搭建个人博客","slug":"hexo + github 搭建个人博客","date":"2018-11-21T17:59:15.656Z","updated":"2018-11-21T17:58:46.722Z","comments":true,"path":"2018/11/22/hexo + github 搭建个人博客/","link":"","permalink":"https://zymmx.github.io/2018/11/22/hexo + github 搭建个人博客/","excerpt":"","text":"hexo + github 搭建个人博客（基础篇）前言：电脑系统为window 10专业版，64位 相关步骤： 1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 原文链接地址：https://www.cnblogs.com/fengxiongZz/p/7707219.html 添加 关于页面使用：hexo new page “about” 新建一个 关于我 页面。主题的 _config.yml 文件中的 menu 中进行匹配 menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可）编辑 about 关于页面 md文件 部署就能看到 进阶链接：http://www.cnblogs.com/fengxiongZz/p/7707568.html 主题链接：https://hexo.io/themes/ 配置文件按需安装 常用命令： 提交 ：commit 更新：cd themes/shana ​ git pull origin master 部署：hexo d -g","categories":[{"name":"杂散","slug":"杂散","permalink":"https://zymmx.github.io/categories/杂散/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zymmx.github.io/tags/hexo/"}]},{"title":"Node.js安装及环境变量配置","slug":"Node.js安装及环境变量配置","date":"2018-11-21T15:39:18.386Z","updated":"2018-11-21T17:54:54.652Z","comments":true,"path":"2018/11/21/Node.js安装及环境变量配置/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Node.js安装及环境变量配置/","excerpt":"","text":"Node.js安装及环境变量配置傻瓜式安装，注意选择保存的路径 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【D:\\Develop\\nodejs】下创建两个文件夹【node_global】及【node_cache】如下图： 创建完两个空文件夹之后，打开cmd命令窗口，输入 12npm config set prefix &quot;D:\\Develop\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Develop\\nodejs\\node_cache&quot; 接下来，关闭命令窗口 进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入【D:\\Develop\\nodejs\\node_global\\node_modules】，将【用户变量】下的【Path】修改为【D:\\Develop\\nodejs\\node_global】 npm config set prefix “E:\\Nodejs\\node_global” npm config set cache “E:\\Nodejs\\node_cache” C:\\Users\\Administrator\\AppData\\Roaming\\npm 配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，输入如下命令进行模块的全局安装： 1npm install express -g # -g是全局安装的意思","categories":[{"name":"杂散","slug":"杂散","permalink":"https://zymmx.github.io/categories/杂散/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zymmx.github.io/tags/js/"}]},{"title":"虚拟机安装及相关环境配置","slug":"虚拟机安装及相关环境配置","date":"2018-11-21T09:56:42.084Z","updated":"2018-07-14T06:13:48.934Z","comments":true,"path":"2018/11/21/虚拟机安装及相关环境配置/","link":"","permalink":"https://zymmx.github.io/2018/11/21/虚拟机安装及相关环境配置/","excerpt":"","text":"虚拟机安装及相关环境配置一：虚拟机安装123456789101112131415161718192021222324252627傻瓜式安装注意断开可移动设备中的cd/dvdsu root命令是切换到root用户passwd 空格 回车是修改密码如果是ssh访问的是别的电脑上的虚拟机，需要将虚拟机的网络设置成桥接ervice sshd status命令查看sshd服务的运行状态如果状态不是running使用命令启动service sshd start使用工具进行远程连接时，需要开放22端口使用iptables开放如下端口（如下开放22端口，其他类似）/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT保存/etc/rc.d/init.d/iptables save重启服务service iptables restart如果配置不成功，或者不想这么麻烦每个端口都配置，可以关闭防火墙关闭防火墙：service iptables stop 二：mysql安装12345678910111213141516171819202122232425262728293031323334351.使用工具（xftp），将压缩包上传到usr/local/software下【usr/local无读写权限限制，software如没有可新建】2.解压，并重命名为mysqlcd /usr/local/softwaretar -zxvf mysql-5.6.38-linux-glibc2.12-x86_64.tar.gz3.cd mysql进入解压后的目录执行下面的命令安装mysql:scripts/mysql_install_db --user=mysql --basedir=/usr/local/software/mysql --datadir=/usr/local/software/mysql/data4.执行vim my.cnf 编辑mysql配置文件，添加如下两行内容：basedir=/usr/local/software/mysqldatadir=/usr/local/software/mysql/data5.执行vim /etc/my.cnf编辑文件，加入两行：basedir=/usr/local/software/mysqldatadir=/usr/local/software/mysql/data6.执行命令cp support-files/mysql.server /etc/init.d/mysql，把启动脚本放到开机初始化目录启动mysql服务：执行命令service mysql start执行命令：ps -ef|grep mysql 看到mysql服务说明启动成功7.输入mysql 回车set password for root@localhost = password(&apos;root&apos;);修改root的密码退出输入quit8.再登录的时候报错：使用mysql –u 用户名 –p登录执行下面的命令，让root可以远程登录：grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;9.linux下的mysql默认是大小写敏感的，通过java操作数据库的时候会出现找不到表的情况，需要设置大小写不敏感vim /etc/my.cnf[mysqld]后添加添加lower_case_table_names=1 三：jdk安装12345678910111213141516171819202122CentOS一般会自带两个jdk，使用命令查看：rpm -qa | grep javarpm -e --nodeps 要卸载的包 (包通过上面的指令可以获取到)]如：rpm -e --nodeps java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64rpm -e --nodeps java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64将下载好的安装包上传到linux的/usr/local/software目录下执行tar -zxvf jdk-8u151-linux-x64.tar.gz命令解压文件配置环境变量vim /etc/profile在文件最末尾加上下面几句话：export JAVA_HOME=/usr/local/software/jdk1.8.0_151export JRE_HOME=/usr/local/software/jdk1.8.0_151/jreexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin保存退出让配置生效：source /etc/profile检查环境：运行java –version能看到版本信息 四：tomcat安装1234567891011121314151617181920同上，上传并解压下载的tomcat进入tomcat解压路径的bin 目录运行 sh startup.sh启动tomcat浏览器里输入 服务器ip:8080能看到欢迎界面可以将tomcat安装成系统服务复制tomcat安装路径下的bin/catalina.sh作为系统服务脚本cp /usr/local/software/apache-tomcat-8.5.23/bin/catalina.sh /etc/init.d/tomcat #重命名的tomcat为以后的服务名修改复制后的文件vim /etc/init.d/tomcat在文件比较靠前的位置，把jdk的安装路经和tomcat的安装路径设置进去# os specific support --------JAVA_HOME=/usr/local/software/jdk1.8.0_151CATALINA_HOME=/usr/local/software/apache-tomcat-8.5.23保存并退出，可以通过service tomcat stop或start来停止或启动tomcat","categories":[{"name":"linux","slug":"linux","permalink":"https://zymmx.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zymmx.github.io/tags/linux/"}]},{"title":"java基础之进程与线程","slug":"java基础之线程","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-13T13:32:30.462Z","comments":true,"path":"2018/11/21/java基础之线程/","link":"","permalink":"https://zymmx.github.io/2018/11/21/java基础之线程/","excerpt":"","text":"java基础之进程与线程进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 线程和进程各自有什么区别和优劣呢？ 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 线程必会基本线程类指的是Thread类，Runnable接口，Callable接口 一：基本方法static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程暂停执行 ，该代码放在什么位置就在什么位置昏睡 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 ​ yield不一定会执行，有很多情况： ​ 1）如果所有的线程已经结束了，就剩下带有yeild方法 ​ 的线程无法谦让 ​ 2）谦让是让出时间片，不保证该线程接着又抢回来 ​ 因为该方法并不是强制性的，所以并不会抛出异常 void join() 等待该线程终止,谁调用就等待谁结束 ，地老天荒 ​ 此时的线程谦让一定成功，具有强制性 ​ 使用哪个线程对象调用就把哪个线程合并到当前线程之前执行 static Thread currentThread() 返回对当前正在执行的线程对象的引用 二：每个对象都有的方法​ wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写 ， synchronized, wait, notify 是任何对象都具有的同步工具 当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。 也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 要注意，notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑，显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while来执行，以确保条件满足和一定执行 共同点： ​ 1）都需要在synchronized代码块里面执行，否则抛出异常 ​ 2）都是Object的方法，所以所有的线程锁对象都可以使用 ​ 3）都需要先获得这把锁才可以执行 ​ 区别： ​ 1）wait方法是使得当前线程对象处于等待状态，并且主动释放对象锁 ​ 并且无法再次获得该锁 ​ 2）notify和notifyAll是使得在该锁上处于等待状态的线程恢复活性 ​ 但是不保证执行，原因是还需要获取时间片才可以，事实上唤醒 ​ 操作使得线程对象还原到Runnable状态 monitor 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667主要用法：synchronized单独使用：代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;直接用于方法： 相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125;synchronized, wait, notify结合:典型场景生产者消费者问题/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;产品已满,请稍候再生产&quot;); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println(&quot;生产者生产第&quot; + this.product + &quot;个产品.&quot;); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;缺货,稍候再取&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println(&quot;消费者取走了第&quot; + this.product + &quot;个产品.&quot;); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; 三：死锁两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。产生四个条件： ​ 请求保持————我不会轻易放弃的，灰太狼 ​ 请求互斥————资源的拥有方本身是矛盾的 ​ 不可剥夺————不能强行剥夺其他的线程的资源 ​ 形成环路————资源本身是唯一的，不可复制 四：ThreadLocal提供一个数据存储，把这个数据共享给每个线程，每个线程都可以自由的增删改这个数据，但是最后修改都是失效的 12345678910111213141516171819202122232425262728293031323334353637383940 常用方法： protected T initialValue() 返回此线程局部变量的当前线程的“初始值” 这个方法在类外无法直接使用，匿名内部类可以解决这个问题 代码： // 构建ThreadLocal的对象，并且初始化线程本地变量 ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; //此时后面的泛型必须要写，否则报错 @Override protected Integer initialValue() &#123; return 10; &#125; &#125;;ThreadLocal多线程操作代码 public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 10; &#125; &#125;; Thread[] ts = new Thread[5]; for (int i = 0; i &lt; ts.length; i++) &#123; ts[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; //获取线程本地化变量的值 Integer number = threadLocal.get(); System.out.println(this+&quot; &quot;+number); //给当前线程的本地化变量赋值 threadLocal.set((int)(Math.random()*10)); System.out.println(this+&quot; &quot;+threadLocal.get()); &#125; &#125;); &#125; for (int i = 0; i &lt; ts.length; i++) &#123; ts[i].start(); &#125; //也就是说线程对ThreadLocal的修改是无效的，但是每个线程都可以获取到ThreadLocal的值 System.out.println(threadLocal.get()); &#125; 五：线程的状态New—-start()——-&gt;&gt;Runnable(可运行状态) —–获取cpu——&gt;&gt;Runing ——run()结束或异常退出—–&gt;&gt;Dead 线程在Running的过程中可能会遇到阻塞(Blocked) 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable） 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。 4.此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 六：线程池","categories":[{"name":"java基础","slug":"java基础","permalink":"https://zymmx.github.io/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://zymmx.github.io/tags/java/"}]},{"title":"Web Service工作原理及实例","slug":"Web Service工作原理及实例","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-11T15:25:15.371Z","comments":true,"path":"2018/11/21/Web Service工作原理及实例/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Web Service工作原理及实例/","excerpt":"","text":"Web Service工作原理及实例一、Web Service基本概念 Web Service也叫XML Web Service WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，*轻量级的独立的通讯技术*。是:通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。 XML：(Extensible Markup Language)扩展型可标记语言。面向短期的临时数据处理、面向万维网络，是Soap的基础。 Soap：(Simple Object Access Protocol)**简单对象存取协议**。是XML Web Service 的通信协议。当用户通过UDDI找到你的WSDL描述文档后，他通过可以SOAP调用你建立的Web服务中的一个或多个操作。SOAP是XML文档形式的调用方法的规范，它可以支持不同的底层接口，像HTTP(S)或者SMTP。 WSDL：(Web Services Description Language) WSDL 文件是一个 XML 文档，用于说明一组 SOAP 消息以及如何交换这些消息。大多数情况下由软件自动生成和使用。 UDDI (Universal Description, Discovery, and Integration) 是一个主要针对Web服务供应商和使用者的新项目。在用户能够调用Web服务之前，必须确定这个服务内包含哪些商务方法，找到被调用的接口定义，还要在服务端来编制软件，UDDI是一种根据描述文档来引导系统查找相应服务的机制。UDDI利用SOAP消息机制（标准的XML/HTTP）来发布，编辑，浏览以及查找注册信息。它采用XML格式来封装各种不同类型的数据，并且发送到注册中心或者由注册中心来返回需要的数据。 二、调用原理​ 实现一个完整的Web服务包括以下步骤： ◆ Web服务提供者设计实现Web服务，并将调试正确后的Web服务通过Web服务中介者发布，并在UDDI注册中心注册； （发布） ◆ Web服务请求者向Web服务中介者请求特定的服务，中介者根据请求查询UDDI注册中心，为请求者寻找满足请求的服务； （发现） ◆ Web服务中介者向Web服务请求者返回满足条件的Web服务描述信息，该描述信息用WSDL写成，各种支持Web服务的机器都能阅读；（发现） ◆ 利用从Web服务中介者返回的描述信息生成相应的SOAP消息，发送给Web服务提供者，以实现Web服务的调用；（绑定） ◆ Web服务提供者按SOAP消息执行相应的Web服务，并将服务结果返回给Web服务请求者。（绑定） 三、调用方式： Net下采用GET/POST/SOAP方式动态调用WebService的简易灵活方法(C#) webservice 的调用有3种方式 1). httpget 2). httppost 3). httpsoap soap 的优点是 可以传递结构化的 数据，而前两种不行。 btw, soap 最终也是使用 HTTP 传送 XM 四、发布WebService实例1. JAX-WS发布WebService创建web工程 创建simple包，和server、client两个子包。正常情况下server和client应该是两个项目，这里我们只是演示效果，所以简化写到一个项目中： ​ 1.1 创建服务类Server123456789101112131415161718192021222324252627282930313233package simple.server;import javax.jws.WebService;import javax.xml.ws.Endpoint;//这里要加上WebService注解@WebServicepublic class SimpleServer &#123; //要发布出去的方法 public String sayHello() &#123; return &quot;hello world&quot;; &#125; //要发布出去的方法 public String speak(@WebParam(name = &quot;word&quot;) String word) &#123; return word + &quot;:webservice&quot;; &#125; ​ //**使用main方法发布出去 public static void main(String[] args) { //**第一个参数是地址，localhost是本机， //9001是端口，端口可以是任意一个未占用的端口 //SimpleService是自己起的服务名，任意 //第二个参数是要发布的这个类的对象 Endpoint.publish(“http://localhost:9001/SimpleService&quot;, new SimpleServer()); System.out.println(“Publish Success~”);//**看到这个输出代表发布成功了 } }** 运行main方法后在浏览器中输入 http://localhost:9001/SimpleService?wsdl 可以看到服务信息： Wsdl文档从下往上读 Types - 数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统)。（入参和出参的数据类型） Message - 通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构（入参和出参）。 Operation - 对服务中所支持的操作的抽象描述，一般单个Operation描述了一个访问入口的请求/响应消息对（方法）。 PortType - 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持（服务类）。 Binding - 特定服务访问点与具体服务类的绑定（不看内容，看关系）。 Port - 定义为webservice单个服务访问点。 Service- 相关服务访问点的集合。 访问上面的schemaLocation=”http://localhost:9001/SimpleService?xsd=1&quot;网址，可以看到具体方法的描述信息 如果要使用web方式发布这个webservice，只需要写一个servlet,并在tomcat启动时就加载这个servlet，在servlet的int方法中发布webservice。 如： 12345678910111213141516171819202122232425262728293031package simple.server;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.xml.ws.Endpoint;public class PublishServlet extends HttpServlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; super.init(servletConfig); //发布webservice Endpoint.publish(&quot;http://localhost:9001/SimpleService&quot;, new SimpleServer()); System.out.println(&quot;Publish Success~&quot;);//看到这个输出代表发布成功了 &#125;&#125; web.xml中配置： 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;PublishServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;simple.server.PublishServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动就加载--&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;PublishServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/publish&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 需要servlet的jar包 1234567891011&lt;!--servlet依赖jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 1.2 创建客户端使用jdk自带命令调用WebService 请求webservice会在本地生成类 wsimport 是请求webservice -encoding utf-8 指定生成的java文件编码格式为utf-8 -s 后面是文件存放的工程路径 -p 是生成的java文件存放的包名 -keep 后面接的是1.1中发布出去的服务地址 运行成功后，工程中会多出几个类： wsimport -encoding utf-8 -s E:\\IdeaCoder\\Examples\\webservice\\src\\main\\java -p onetest.client -keep http://localhost:9002/SimpleSer?wsdl 一般外部，只需跟环最后 wsimport -encoding utf-8 -s E:\\IdeaCoder\\SourceDrop\\lmh_webservice\\src\\main\\java -p outer.captcha -keep http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl 创建测试客户端类MySimpleClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package simple.client;import org.junit.Test;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;public class MySimpleClient &#123; @Test public void testJdkMethod() &#123; //&lt;service name=&quot;SimpleServerService&quot;&gt; // &lt;port name=&quot;SimpleServerPort&quot; binding=&quot;tns:SimpleServerPortBinding&quot;&gt; // &lt;soap:address location=&quot;http://localhost:9001/SimpleService&quot;/&gt; // &lt;/port&gt; // &lt;/service&gt; //这个是xml文件中的service-name // &lt;service name=&quot;SimpleServerService&quot;&gt; SimpleServerService simpleServerService = new SimpleServerService(); //这个是&lt;port name=&quot;SimpleServerPort&quot; SimpleServer simpleServer = simpleServerService.getSimpleServerPort(); System.out.println(simpleServer.sayHello()); &#125; 1&#125; 通过jdk生成的SimpleServer，可以调用相应的方法，实际上返回响应的是服务器，但执行的时候就像调用自己写的类一样。可以清楚的看到方法和参数。 另一种调用的方式，直接使用java方法，不生成类： 新建一个other包，存放如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package simple.other;import javax.jws.WebMethod;import javax.jws.WebParam;import javax.jws.WebService;import javax.xml.bind.annotation.XmlSeeAlso;import javax.xml.ws.RequestWrapper;import javax.xml.ws.ResponseWrapper;//对应xml文件//&lt;definitions targetNamespace=&quot;http://server.simple/&quot; name=&quot;SimpleServerService&quot;&gt;@WebService(name = &quot;SimpleServerService&quot;, targetNamespace = &quot;http://server.simple/&quot;)@XmlSeeAlso(&#123;&#125;)public interface MySimpleClient &#123; @WebMethod @RequestWrapper(localName = &quot;sayHello&quot;) @ResponseWrapper(localName = &quot;sayHelloResponse&quot;) public String sayHello(); @WebMethod @RequestWrapper(localName = &quot;speak&quot;) @ResponseWrapper(localName = &quot;speakResponse&quot;) public String speak(@WebParam(name = &quot;word&quot;)String word);&#125; 测试代码： 123456789101112131415161718192021package simple.other;import javax.xml.namespace.QName;import javax.xml.ws.Service;import java.net.URL;public class OtherTest &#123; public static void main(String[] args) throws Exception &#123; URL wsdlUrl = new URL(&quot;http://localhost:9001/SimpleService?wsdl&quot;); // targetNamespace=&quot;http://server.simple/&quot; name=&quot;SimpleServerService&quot; Service s = Service.create(wsdlUrl, 123 new QName(&quot;http://server.simple/&quot;,&quot;SimpleServerService&quot;));MySimpleClient client = 1s.getPort( 1new QName(&quot;http://server.simple/&quot;, 1&quot;SimpleServerPort&quot;), 123456789 MySimpleClient.class); System.out.println(client.sayHello()); System.out.println(client.speak(&quot;123&quot;)); &#125;&#125; 2. cxf发布WebServiceJAX-WS是一种规范，CXF是他的实现。CXF可以不必关心服务端的实现方式。 为了简化代码，我们把服务端和客户端写在一个工程里，正常应该写在两个工程 2.1 发布服务新建web工程，导入jar包： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf.karaf&lt;/groupId&gt; &lt;artifactId&gt;apache-cxf&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志文件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CXF发布服务需要一个接口和一个实现类： 123456789101112131415161718192021package server;import javax.jws.WebParam;import javax.jws.WebService;@WebService(name = &quot;CXF&quot;, targetNamespace = &quot;http://server.cxf/&quot;)public interface CxfServer &#123; String sayHello(); String speak(@WebParam(name = &quot;word&quot;) String world);&#125; 实现类： 12345678910111213141516171819202122232425package server;public class CxfServerImpl implements CxfServer &#123; @Override public String sayHello() &#123; return &quot;Hello CXF&quot;; &#125; @Override public String speak(String word) &#123; return word + &quot;CXF&quot;; &#125;&#125; 发布服务： 123456789101112131415161718192021222324252627282930313233343536373839package server;import org.apache.cxf.jaxws.JaxWsServerFactoryBean;public class CXFServerTest &#123; public static void main(String[] args) &#123; // 创建JaxWsServerFactoryBean对象 JaxWsServerFactoryBean serverFactoryBean = new JaxWsServerFactoryBean(); // 设置服务端地址 serverFactoryBean.setAddress(&quot;http://127.0.0.1:9999/cxf&quot;); // 设置服务接口 serverFactoryBean.setServiceClass(CxfServer.class); // 设置实现类对象 serverFactoryBean.setServiceBean(new CxfServerImpl()); // 发布服务 serverFactoryBean.create(); System.out.println(&quot;发布成功&quot;); &#125;&#125; 浏览器中访问：http://127.0.0.1:9999/cxf?wsdl 2.2 调用服务123456789101112131415package client;import org.apache.cxf.endpoint.Client;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class CxfClientTest &#123; public static void main(String[] args) throws Exception &#123; JaxWsDynamicClientFactory clientFactory = 1234567891011121314151617 JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient(&quot;http://127.0.0.1:9999/cxf?wsdl&quot;); //直接调用方法，不用关心服务端是怎么实现的 Object[] result = client.invoke(&quot;sayHello&quot;); System.out.println(result[0]); Object[] result2 = client.invoke(&quot;speak&quot;, &quot;123&quot;); System.out.println(result2[0]); &#125;&#125; 2.3 Spring与CXF集成引入spring的jar 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring-cxf.xml配置 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot;http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsdhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--发布服务implementor是接口实现类，address在访问的时候加载路径里--&gt; &lt;jaxws:endpoint id=&quot;cxfDemo&quot; implementor=&quot;server.CxfServerImpl&quot; address=&quot;/cxf&quot;/&gt;&lt;/beans&gt; web.xml中配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-cxf.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 使用spring发布的时候，在接口实现类上加上注解，保证发布出去的targetNamespace一致： 123@WebService(name = &quot;CXF&quot;, targetNamespace = &quot;http://server.cxf/&quot;)public class CxfServerImpl implements CxfServer &#123; 浏览器中访问：http://127.0.0.1:8080/services/cxf?wsdl 测试方法与2.2中相同，更换访问地址即可。","categories":[{"name":"服务","slug":"服务","permalink":"https://zymmx.github.io/categories/服务/"}],"tags":[{"name":"webservice","slug":"webservice","permalink":"https://zymmx.github.io/tags/webservice/"}]},{"title":"Dubbox+Zookeeper入门","slug":"Dubbox","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-14T06:05:25.255Z","comments":true,"path":"2018/11/21/Dubbox/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Dubbox/","excerpt":"","text":"DubboxDubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。 Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。 节点角色说明：  Provider: 暴露服务的服务提供方。  Consumer: 调用远程服务的服务消费方。  Registry: 服务注册与发现的注册中心。  Monitor: 统计服务的调用次调和调用时间的监控中心。  Container: 服务运行容器。 调用关系说明：  0. 服务容器负责启动，加载，运行服务提供者。  1. 服务提供者在启动时，向注册中心注册自己提供的服务。  2. 服务消费者在启动时，向注册中心订阅自己所需的服务。  3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推 送变更数据给消费者。  4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用， 如果调用失败，再选另一台调用。  5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计 数据到监控中心 注册中心Zookeeper官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 Zookeeper 是Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。 Zookeeper 在Linux系统的安装1：安装jdk 2：上传安装包：Alt+P 进入SFTP ，输入put d:\\zookeeper-3.4.6.tar.gz 上传 ；也可以直接用工具拖动上传 3： 解压：tar -zxvf zookeeper-3.4.6.tar.gz 4： 进入 zookeeper-3.4.6 目录，创建 data 文件夹 ：mkdir data 5： 进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg ： ​ cd conf ​ mv zoo_sample.cfg zoo.cfg 6： 打开zoo.cfg , 修改 data 属性：dataDir=/root/zookeeper-3.4.6/data （安装路径） 7： 启动：进入bin里，执行启动程序 ：./zkServer.sh start Dubbox本地 JAR包部署与安装Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。 我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。 先将dubbo-2.8.4.jar包放到d:\\setup, 然后输入命令 mvn install:install-file -Dfile=d:\\setup\\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar Eclipse配置离线约束 (将dubbo.xsd文件配置上：windows —-&gt;preferences—–&gt;xml catalog) http://code.alibabatech.com/schema/dubbo/dubbo.xsd 管理中心的部署我们在开发时，需要知道注册中心都注册了哪些服务，以便我们开发和测试。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 管理端安装 （1）编译源码，得到war包 我们有个dubbox-master.zip ，这个是dubbox的源码，我们可以使用maven命令编译源码得到“管理端”的war包 将此压缩包解压，在命令符下进入dubbo-admin目录 ，输入maven命令 mvn package -Dmaven.skip.test=true （2）进入target文件夹，你会看到一个dubbo-admin-2.8.4.war ， 在linux服务器上安装tomcat, 将此war包上传到linux服务器的tomcat的webapps下。为了访问方便，你可以把版本号去掉。 启动tomcat后自动解压。 （3）如果你部署在zookeeper同一台主机并且端口是默认的2181，则无需修改任何配置。如果不是在一台主机上或端口被修改，需要修改WEB-INF下的dubbo.properties ，修改如下配置： dubbo.registry.address=zookeeper://127.0.0.1:2181 （4）打开浏览器，输入http://部署的linux主机地址:8080/dubbo-admin/ ,登录用户名和密码均为root 进入首页。","categories":[{"name":"架构","slug":"架构","permalink":"https://zymmx.github.io/categories/架构/"}],"tags":[{"name":"soa","slug":"soa","permalink":"https://zymmx.github.io/tags/soa/"}]},{"title":"AngularJS入门","slug":"AngularJS","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-14T06:12:41.917Z","comments":true,"path":"2018/11/21/AngularJS/","link":"","permalink":"https://zymmx.github.io/2018/11/21/AngularJS/","excerpt":"","text":"AngularJS四大特征MVC: Model:数据,其实就是angular变量($scope.XX); View: 数据的呈现,Html+Directive(指令); Controller:操作数据,就是function,数据的增删改查; 双向绑定：声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。 依赖注入：依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI. 模块化设计：高内聚低耦合法则 （官方提供的模块（ng等），自定义模块） 指令及入门demong-app指令:告诉子元素一下的指令是归angularJs的,angularJs会识别的 ;定义了 AngularJS 应用程序的 根元素 ;在网页加载完毕时会自动引导（自动初始化）应用程序。 123456789101112demo01:双向绑定&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-1 双向绑定&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;&#123;&#123;myname&#125;&#125;,你好&lt;/body&gt;&lt;/html&gt; ng-model指令：用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。 ng-init指令来对变量初始化 123456789101112demo02用ng-init指令来对变量初始化&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-2 初始化&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;&#123;&#123;myname&#125;&#125;,你好&lt;/body&gt;&lt;/html&gt; ng-controller：用于指定所使用的控制器。 123456789101112131415161718192021222324demo03控制器指令的使用&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-3 事件指令&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.add=function()&#123; $scope.z= parseInt($scope.x)+parseInt($scope.y); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：&#123;&#123;z&#125;&#125;&lt;/body&gt;&lt;/html&gt;$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图. ng-repeat指令：用于循环数组变量 123456789101112131415161718192021demo04:ng-repeat=&quot;x in list&quot;数组的值传入x中&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-4 循环数据&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.list= [100,192,203,434 ];//定义数组 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt; &lt;td&gt;&#123;&#123;x&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132demo05:循环对象数组&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-5 循环对象数组&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.list= [ &#123;name:&apos;张三&apos;,shuxue:100,yuwen:93&#125;, &#123;name:&apos;李四&apos;,shuxue:88,yuwen:87&#125;, &#123;name:&apos;王五&apos;,shuxue:77,yuwen:56&#125; ];//定义数组 &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.shuxue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.yuwen&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; $http ：内置服务，从后端获取数据 1234567891011121314151617181920212223242526272829303132333435demo05:内置服务&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-8 内置服务&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope,$http)&#123; $scope.findAll=function()&#123; $http.get(&apos;../后台传来的json数据地址&apos;).success( function(response)&#123; $scope.list=response; &#125; ); &#125; &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.shuxue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.yuwen&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zymmx.github.io/tags/web/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-21T03:29:27.140Z","updated":"2018-11-21T03:29:27.140Z","comments":true,"path":"2018/11/21/hello-world/","link":"","permalink":"https://zymmx.github.io/2018/11/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}