{"meta":{"title":"木木夕","subtitle":null,"description":"如梦江湖 如戏人生","author":"木木夕","url":"https://zymmx.github.io"},"pages":[{"title":"404","date":"2018-11-21T06:39:09.000Z","updated":"2018-11-21T06:39:09.237Z","comments":true,"path":"404/index.html","permalink":"https://zymmx.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-21T06:38:53.000Z","updated":"2018-11-21T06:38:53.349Z","comments":true,"path":"search/index.html","permalink":"https://zymmx.github.io/search/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-21T15:03:42.000Z","updated":"2018-11-23T10:20:35.233Z","comments":true,"path":"about/index.html","permalink":"https://zymmx.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-21T08:14:18.642Z","updated":"2018-11-21T08:14:18.642Z","comments":true,"path":"tags/index.html","permalink":"https://zymmx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-21T15:00:49.764Z","updated":"2018-11-21T08:14:18.642Z","comments":true,"path":"categories/index.html","permalink":"https://zymmx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo + github 搭建个人博客","slug":"hexo + github 搭建个人博客","date":"2018-11-21T17:59:15.656Z","updated":"2018-11-21T17:58:46.722Z","comments":true,"path":"2018/11/22/hexo + github 搭建个人博客/","link":"","permalink":"https://zymmx.github.io/2018/11/22/hexo + github 搭建个人博客/","excerpt":"","text":"hexo + github 搭建个人博客（基础篇）前言：电脑系统为window 10专业版，64位 相关步骤： 1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 原文链接地址：https://www.cnblogs.com/fengxiongZz/p/7707219.html 添加 关于页面使用：hexo new page “about” 新建一个 关于我 页面。主题的 _config.yml 文件中的 menu 中进行匹配 menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可）编辑 about 关于页面 md文件 部署就能看到 进阶链接：http://www.cnblogs.com/fengxiongZz/p/7707568.html 主题链接：https://hexo.io/themes/ 配置文件按需安装 常用命令： 提交 ：commit 更新：cd themes/shana ​ git pull origin master 部署：hexo d -g","categories":[{"name":"杂散","slug":"杂散","permalink":"https://zymmx.github.io/categories/杂散/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zymmx.github.io/tags/hexo/"}]},{"title":"Node.js安装及环境变量配置","slug":"Node.js安装及环境变量配置","date":"2018-11-21T15:39:18.386Z","updated":"2018-11-21T17:54:54.652Z","comments":true,"path":"2018/11/21/Node.js安装及环境变量配置/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Node.js安装及环境变量配置/","excerpt":"","text":"Node.js安装及环境变量配置傻瓜式安装，注意选择保存的路径 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【D:\\Develop\\nodejs】下创建两个文件夹【node_global】及【node_cache】如下图： 创建完两个空文件夹之后，打开cmd命令窗口，输入 12npm config set prefix &quot;D:\\Develop\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Develop\\nodejs\\node_cache&quot; 接下来，关闭命令窗口 进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入【D:\\Develop\\nodejs\\node_global\\node_modules】，将【用户变量】下的【Path】修改为【D:\\Develop\\nodejs\\node_global】 npm config set prefix “E:\\Nodejs\\node_global” npm config set cache “E:\\Nodejs\\node_cache” C:\\Users\\Administrator\\AppData\\Roaming\\npm 配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，输入如下命令进行模块的全局安装： 1npm install express -g # -g是全局安装的意思","categories":[{"name":"杂散","slug":"杂散","permalink":"https://zymmx.github.io/categories/杂散/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zymmx.github.io/tags/js/"}]},{"title":"虚拟机安装及相关环境配置","slug":"虚拟机安装及相关环境配置","date":"2018-11-21T09:56:42.084Z","updated":"2018-07-14T06:13:48.934Z","comments":true,"path":"2018/11/21/虚拟机安装及相关环境配置/","link":"","permalink":"https://zymmx.github.io/2018/11/21/虚拟机安装及相关环境配置/","excerpt":"","text":"虚拟机安装及相关环境配置一：虚拟机安装123456789101112131415161718192021222324252627傻瓜式安装注意断开可移动设备中的cd/dvdsu root命令是切换到root用户passwd 空格 回车是修改密码如果是ssh访问的是别的电脑上的虚拟机，需要将虚拟机的网络设置成桥接ervice sshd status命令查看sshd服务的运行状态如果状态不是running使用命令启动service sshd start使用工具进行远程连接时，需要开放22端口使用iptables开放如下端口（如下开放22端口，其他类似）/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT保存/etc/rc.d/init.d/iptables save重启服务service iptables restart如果配置不成功，或者不想这么麻烦每个端口都配置，可以关闭防火墙关闭防火墙：service iptables stop 二：mysql安装12345678910111213141516171819202122232425262728293031323334351.使用工具（xftp），将压缩包上传到usr/local/software下【usr/local无读写权限限制，software如没有可新建】2.解压，并重命名为mysqlcd /usr/local/softwaretar -zxvf mysql-5.6.38-linux-glibc2.12-x86_64.tar.gz3.cd mysql进入解压后的目录执行下面的命令安装mysql:scripts/mysql_install_db --user=mysql --basedir=/usr/local/software/mysql --datadir=/usr/local/software/mysql/data4.执行vim my.cnf 编辑mysql配置文件，添加如下两行内容：basedir=/usr/local/software/mysqldatadir=/usr/local/software/mysql/data5.执行vim /etc/my.cnf编辑文件，加入两行：basedir=/usr/local/software/mysqldatadir=/usr/local/software/mysql/data6.执行命令cp support-files/mysql.server /etc/init.d/mysql，把启动脚本放到开机初始化目录启动mysql服务：执行命令service mysql start执行命令：ps -ef|grep mysql 看到mysql服务说明启动成功7.输入mysql 回车set password for root@localhost = password(&apos;root&apos;);修改root的密码退出输入quit8.再登录的时候报错：使用mysql –u 用户名 –p登录执行下面的命令，让root可以远程登录：grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;9.linux下的mysql默认是大小写敏感的，通过java操作数据库的时候会出现找不到表的情况，需要设置大小写不敏感vim /etc/my.cnf[mysqld]后添加添加lower_case_table_names=1 三：jdk安装12345678910111213141516171819202122CentOS一般会自带两个jdk，使用命令查看：rpm -qa | grep javarpm -e --nodeps 要卸载的包 (包通过上面的指令可以获取到)]如：rpm -e --nodeps java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64rpm -e --nodeps java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64将下载好的安装包上传到linux的/usr/local/software目录下执行tar -zxvf jdk-8u151-linux-x64.tar.gz命令解压文件配置环境变量vim /etc/profile在文件最末尾加上下面几句话：export JAVA_HOME=/usr/local/software/jdk1.8.0_151export JRE_HOME=/usr/local/software/jdk1.8.0_151/jreexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin保存退出让配置生效：source /etc/profile检查环境：运行java –version能看到版本信息 四：tomcat安装1234567891011121314151617181920同上，上传并解压下载的tomcat进入tomcat解压路径的bin 目录运行 sh startup.sh启动tomcat浏览器里输入 服务器ip:8080能看到欢迎界面可以将tomcat安装成系统服务复制tomcat安装路径下的bin/catalina.sh作为系统服务脚本cp /usr/local/software/apache-tomcat-8.5.23/bin/catalina.sh /etc/init.d/tomcat #重命名的tomcat为以后的服务名修改复制后的文件vim /etc/init.d/tomcat在文件比较靠前的位置，把jdk的安装路经和tomcat的安装路径设置进去# os specific support --------JAVA_HOME=/usr/local/software/jdk1.8.0_151CATALINA_HOME=/usr/local/software/apache-tomcat-8.5.23保存并退出，可以通过service tomcat stop或start来停止或启动tomcat","categories":[{"name":"linux","slug":"linux","permalink":"https://zymmx.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zymmx.github.io/tags/linux/"}]},{"title":"AngularJS入门","slug":"AngularJS","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-14T06:12:41.917Z","comments":true,"path":"2018/11/21/AngularJS/","link":"","permalink":"https://zymmx.github.io/2018/11/21/AngularJS/","excerpt":"","text":"AngularJS四大特征MVC: Model:数据,其实就是angular变量($scope.XX); View: 数据的呈现,Html+Directive(指令); Controller:操作数据,就是function,数据的增删改查; 双向绑定：声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。 依赖注入：依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI. 模块化设计：高内聚低耦合法则 （官方提供的模块（ng等），自定义模块） 指令及入门demong-app指令:告诉子元素一下的指令是归angularJs的,angularJs会识别的 ;定义了 AngularJS 应用程序的 根元素 ;在网页加载完毕时会自动引导（自动初始化）应用程序。 123456789101112demo01:双向绑定&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-1 双向绑定&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;&#123;&#123;myname&#125;&#125;,你好&lt;/body&gt;&lt;/html&gt; ng-model指令：用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。 ng-init指令来对变量初始化 123456789101112demo02用ng-init指令来对变量初始化&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-2 初始化&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;&#123;&#123;myname&#125;&#125;,你好&lt;/body&gt;&lt;/html&gt; ng-controller：用于指定所使用的控制器。 123456789101112131415161718192021222324demo03控制器指令的使用&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-3 事件指令&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.add=function()&#123; $scope.z= parseInt($scope.x)+parseInt($scope.y); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：&#123;&#123;z&#125;&#125;&lt;/body&gt;&lt;/html&gt;$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图. ng-repeat指令：用于循环数组变量 123456789101112131415161718192021demo04:ng-repeat=&quot;x in list&quot;数组的值传入x中&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-4 循环数据&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.list= [100,192,203,434 ];//定义数组 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt; &lt;td&gt;&#123;&#123;x&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132demo05:循环对象数组&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-5 循环对象数组&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.list= [ &#123;name:&apos;张三&apos;,shuxue:100,yuwen:93&#125;, &#123;name:&apos;李四&apos;,shuxue:88,yuwen:87&#125;, &#123;name:&apos;王五&apos;,shuxue:77,yuwen:56&#125; ];//定义数组 &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.shuxue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.yuwen&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; $http ：内置服务，从后端获取数据 1234567891011121314151617181920212223242526272829303132333435demo05:内置服务&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-8 内置服务&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope,$http)&#123; $scope.findAll=function()&#123; $http.get(&apos;../后台传来的json数据地址&apos;).success( function(response)&#123; $scope.list=response; &#125; ); &#125; &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.shuxue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.yuwen&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zymmx.github.io/tags/web/"}]},{"title":"Dubbox+Zookeeper入门","slug":"Dubbox","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-14T06:05:25.255Z","comments":true,"path":"2018/11/21/Dubbox/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Dubbox/","excerpt":"","text":"DubboxDubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。 Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。 节点角色说明：  Provider: 暴露服务的服务提供方。  Consumer: 调用远程服务的服务消费方。  Registry: 服务注册与发现的注册中心。  Monitor: 统计服务的调用次调和调用时间的监控中心。  Container: 服务运行容器。 调用关系说明：  0. 服务容器负责启动，加载，运行服务提供者。  1. 服务提供者在启动时，向注册中心注册自己提供的服务。  2. 服务消费者在启动时，向注册中心订阅自己所需的服务。  3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推 送变更数据给消费者。  4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用， 如果调用失败，再选另一台调用。  5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计 数据到监控中心 注册中心Zookeeper官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 Zookeeper 是Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。 Zookeeper 在Linux系统的安装1：安装jdk 2：上传安装包：Alt+P 进入SFTP ，输入put d:\\zookeeper-3.4.6.tar.gz 上传 ；也可以直接用工具拖动上传 3： 解压：tar -zxvf zookeeper-3.4.6.tar.gz 4： 进入 zookeeper-3.4.6 目录，创建 data 文件夹 ：mkdir data 5： 进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg ： ​ cd conf ​ mv zoo_sample.cfg zoo.cfg 6： 打开zoo.cfg , 修改 data 属性：dataDir=/root/zookeeper-3.4.6/data （安装路径） 7： 启动：进入bin里，执行启动程序 ：./zkServer.sh start Dubbox本地 JAR包部署与安装Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。 我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。 先将dubbo-2.8.4.jar包放到d:\\setup, 然后输入命令 mvn install:install-file -Dfile=d:\\setup\\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar Eclipse配置离线约束 (将dubbo.xsd文件配置上：windows —-&gt;preferences—–&gt;xml catalog) http://code.alibabatech.com/schema/dubbo/dubbo.xsd 管理中心的部署我们在开发时，需要知道注册中心都注册了哪些服务，以便我们开发和测试。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 管理端安装 （1）编译源码，得到war包 我们有个dubbox-master.zip ，这个是dubbox的源码，我们可以使用maven命令编译源码得到“管理端”的war包 将此压缩包解压，在命令符下进入dubbo-admin目录 ，输入maven命令 mvn package -Dmaven.skip.test=true （2）进入target文件夹，你会看到一个dubbo-admin-2.8.4.war ， 在linux服务器上安装tomcat, 将此war包上传到linux服务器的tomcat的webapps下。为了访问方便，你可以把版本号去掉。 启动tomcat后自动解压。 （3）如果你部署在zookeeper同一台主机并且端口是默认的2181，则无需修改任何配置。如果不是在一台主机上或端口被修改，需要修改WEB-INF下的dubbo.properties ，修改如下配置： dubbo.registry.address=zookeeper://127.0.0.1:2181 （4）打开浏览器，输入http://部署的linux主机地址:8080/dubbo-admin/ ,登录用户名和密码均为root 进入首页。","categories":[{"name":"架构","slug":"架构","permalink":"https://zymmx.github.io/categories/架构/"}],"tags":[{"name":"soa","slug":"soa","permalink":"https://zymmx.github.io/tags/soa/"}]},{"title":"java基础之进程与线程","slug":"java基础之线程","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-13T13:32:30.462Z","comments":true,"path":"2018/11/21/java基础之线程/","link":"","permalink":"https://zymmx.github.io/2018/11/21/java基础之线程/","excerpt":"","text":"java基础之进程与线程进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 线程和进程各自有什么区别和优劣呢？ 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 线程必会基本线程类指的是Thread类，Runnable接口，Callable接口 一：基本方法static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程暂停执行 ，该代码放在什么位置就在什么位置昏睡 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 ​ yield不一定会执行，有很多情况： ​ 1）如果所有的线程已经结束了，就剩下带有yeild方法 ​ 的线程无法谦让 ​ 2）谦让是让出时间片，不保证该线程接着又抢回来 ​ 因为该方法并不是强制性的，所以并不会抛出异常 void join() 等待该线程终止,谁调用就等待谁结束 ，地老天荒 ​ 此时的线程谦让一定成功，具有强制性 ​ 使用哪个线程对象调用就把哪个线程合并到当前线程之前执行 static Thread currentThread() 返回对当前正在执行的线程对象的引用 二：每个对象都有的方法​ wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写 ， synchronized, wait, notify 是任何对象都具有的同步工具 当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。 也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 要注意，notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑，显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while来执行，以确保条件满足和一定执行 共同点： ​ 1）都需要在synchronized代码块里面执行，否则抛出异常 ​ 2）都是Object的方法，所以所有的线程锁对象都可以使用 ​ 3）都需要先获得这把锁才可以执行 ​ 区别： ​ 1）wait方法是使得当前线程对象处于等待状态，并且主动释放对象锁 ​ 并且无法再次获得该锁 ​ 2）notify和notifyAll是使得在该锁上处于等待状态的线程恢复活性 ​ 但是不保证执行，原因是还需要获取时间片才可以，事实上唤醒 ​ 操作使得线程对象还原到Runnable状态 monitor 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667主要用法：synchronized单独使用：代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;直接用于方法： 相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125;synchronized, wait, notify结合:典型场景生产者消费者问题/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;产品已满,请稍候再生产&quot;); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println(&quot;生产者生产第&quot; + this.product + &quot;个产品.&quot;); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;缺货,稍候再取&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println(&quot;消费者取走了第&quot; + this.product + &quot;个产品.&quot;); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; 三：死锁两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。产生四个条件： ​ 请求保持————我不会轻易放弃的，灰太狼 ​ 请求互斥————资源的拥有方本身是矛盾的 ​ 不可剥夺————不能强行剥夺其他的线程的资源 ​ 形成环路————资源本身是唯一的，不可复制 四：ThreadLocal提供一个数据存储，把这个数据共享给每个线程，每个线程都可以自由的增删改这个数据，但是最后修改都是失效的 12345678910111213141516171819202122232425262728293031323334353637383940 常用方法： protected T initialValue() 返回此线程局部变量的当前线程的“初始值” 这个方法在类外无法直接使用，匿名内部类可以解决这个问题 代码： // 构建ThreadLocal的对象，并且初始化线程本地变量 ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; //此时后面的泛型必须要写，否则报错 @Override protected Integer initialValue() &#123; return 10; &#125; &#125;;ThreadLocal多线程操作代码 public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 10; &#125; &#125;; Thread[] ts = new Thread[5]; for (int i = 0; i &lt; ts.length; i++) &#123; ts[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; //获取线程本地化变量的值 Integer number = threadLocal.get(); System.out.println(this+&quot; &quot;+number); //给当前线程的本地化变量赋值 threadLocal.set((int)(Math.random()*10)); System.out.println(this+&quot; &quot;+threadLocal.get()); &#125; &#125;); &#125; for (int i = 0; i &lt; ts.length; i++) &#123; ts[i].start(); &#125; //也就是说线程对ThreadLocal的修改是无效的，但是每个线程都可以获取到ThreadLocal的值 System.out.println(threadLocal.get()); &#125; 五：线程的状态New—-start()——-&gt;&gt;Runnable(可运行状态) —–获取cpu——&gt;&gt;Runing ——run()结束或异常退出—–&gt;&gt;Dead 线程在Running的过程中可能会遇到阻塞(Blocked) 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable） 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。 4.此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 六：线程池","categories":[{"name":"java基础","slug":"java基础","permalink":"https://zymmx.github.io/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://zymmx.github.io/tags/java/"}]},{"title":"Web Service工作原理及实例","slug":"Web Service工作原理及实例","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-11T15:25:15.371Z","comments":true,"path":"2018/11/21/Web Service工作原理及实例/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Web Service工作原理及实例/","excerpt":"","text":"Web Service工作原理及实例一、Web Service基本概念 Web Service也叫XML Web Service WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，*轻量级的独立的通讯技术*。是:通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。 XML：(Extensible Markup Language)扩展型可标记语言。面向短期的临时数据处理、面向万维网络，是Soap的基础。 Soap：(Simple Object Access Protocol)**简单对象存取协议**。是XML Web Service 的通信协议。当用户通过UDDI找到你的WSDL描述文档后，他通过可以SOAP调用你建立的Web服务中的一个或多个操作。SOAP是XML文档形式的调用方法的规范，它可以支持不同的底层接口，像HTTP(S)或者SMTP。 WSDL：(Web Services Description Language) WSDL 文件是一个 XML 文档，用于说明一组 SOAP 消息以及如何交换这些消息。大多数情况下由软件自动生成和使用。 UDDI (Universal Description, Discovery, and Integration) 是一个主要针对Web服务供应商和使用者的新项目。在用户能够调用Web服务之前，必须确定这个服务内包含哪些商务方法，找到被调用的接口定义，还要在服务端来编制软件，UDDI是一种根据描述文档来引导系统查找相应服务的机制。UDDI利用SOAP消息机制（标准的XML/HTTP）来发布，编辑，浏览以及查找注册信息。它采用XML格式来封装各种不同类型的数据，并且发送到注册中心或者由注册中心来返回需要的数据。 二、调用原理​ 实现一个完整的Web服务包括以下步骤： ◆ Web服务提供者设计实现Web服务，并将调试正确后的Web服务通过Web服务中介者发布，并在UDDI注册中心注册； （发布） ◆ Web服务请求者向Web服务中介者请求特定的服务，中介者根据请求查询UDDI注册中心，为请求者寻找满足请求的服务； （发现） ◆ Web服务中介者向Web服务请求者返回满足条件的Web服务描述信息，该描述信息用WSDL写成，各种支持Web服务的机器都能阅读；（发现） ◆ 利用从Web服务中介者返回的描述信息生成相应的SOAP消息，发送给Web服务提供者，以实现Web服务的调用；（绑定） ◆ Web服务提供者按SOAP消息执行相应的Web服务，并将服务结果返回给Web服务请求者。（绑定） 三、调用方式： Net下采用GET/POST/SOAP方式动态调用WebService的简易灵活方法(C#) webservice 的调用有3种方式 1). httpget 2). httppost 3). httpsoap soap 的优点是 可以传递结构化的 数据，而前两种不行。 btw, soap 最终也是使用 HTTP 传送 XM 四、发布WebService实例1. JAX-WS发布WebService创建web工程 创建simple包，和server、client两个子包。正常情况下server和client应该是两个项目，这里我们只是演示效果，所以简化写到一个项目中： ​ 1.1 创建服务类Server123456789101112131415161718192021222324252627282930313233package simple.server;import javax.jws.WebService;import javax.xml.ws.Endpoint;//这里要加上WebService注解@WebServicepublic class SimpleServer &#123; //要发布出去的方法 public String sayHello() &#123; return &quot;hello world&quot;; &#125; //要发布出去的方法 public String speak(@WebParam(name = &quot;word&quot;) String word) &#123; return word + &quot;:webservice&quot;; &#125; ​ //**使用main方法发布出去 public static void main(String[] args) { //**第一个参数是地址，localhost是本机， //9001是端口，端口可以是任意一个未占用的端口 //SimpleService是自己起的服务名，任意 //第二个参数是要发布的这个类的对象 Endpoint.publish(“http://localhost:9001/SimpleService&quot;, new SimpleServer()); System.out.println(“Publish Success~”);//**看到这个输出代表发布成功了 } }** 运行main方法后在浏览器中输入 http://localhost:9001/SimpleService?wsdl 可以看到服务信息： Wsdl文档从下往上读 Types - 数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统)。（入参和出参的数据类型） Message - 通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构（入参和出参）。 Operation - 对服务中所支持的操作的抽象描述，一般单个Operation描述了一个访问入口的请求/响应消息对（方法）。 PortType - 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持（服务类）。 Binding - 特定服务访问点与具体服务类的绑定（不看内容，看关系）。 Port - 定义为webservice单个服务访问点。 Service- 相关服务访问点的集合。 访问上面的schemaLocation=”http://localhost:9001/SimpleService?xsd=1&quot;网址，可以看到具体方法的描述信息 如果要使用web方式发布这个webservice，只需要写一个servlet,并在tomcat启动时就加载这个servlet，在servlet的int方法中发布webservice。 如： 12345678910111213141516171819202122232425262728293031package simple.server;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.xml.ws.Endpoint;public class PublishServlet extends HttpServlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; super.init(servletConfig); //发布webservice Endpoint.publish(&quot;http://localhost:9001/SimpleService&quot;, new SimpleServer()); System.out.println(&quot;Publish Success~&quot;);//看到这个输出代表发布成功了 &#125;&#125; web.xml中配置： 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;PublishServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;simple.server.PublishServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动就加载--&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;PublishServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/publish&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 需要servlet的jar包 1234567891011&lt;!--servlet依赖jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 1.2 创建客户端使用jdk自带命令调用WebService 请求webservice会在本地生成类 wsimport 是请求webservice -encoding utf-8 指定生成的java文件编码格式为utf-8 -s 后面是文件存放的工程路径 -p 是生成的java文件存放的包名 -keep 后面接的是1.1中发布出去的服务地址 运行成功后，工程中会多出几个类： wsimport -encoding utf-8 -s E:\\IdeaCoder\\Examples\\webservice\\src\\main\\java -p onetest.client -keep http://localhost:9002/SimpleSer?wsdl 一般外部，只需跟环最后 wsimport -encoding utf-8 -s E:\\IdeaCoder\\SourceDrop\\lmh_webservice\\src\\main\\java -p outer.captcha -keep http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl 创建测试客户端类MySimpleClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package simple.client;import org.junit.Test;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;public class MySimpleClient &#123; @Test public void testJdkMethod() &#123; //&lt;service name=&quot;SimpleServerService&quot;&gt; // &lt;port name=&quot;SimpleServerPort&quot; binding=&quot;tns:SimpleServerPortBinding&quot;&gt; // &lt;soap:address location=&quot;http://localhost:9001/SimpleService&quot;/&gt; // &lt;/port&gt; // &lt;/service&gt; //这个是xml文件中的service-name // &lt;service name=&quot;SimpleServerService&quot;&gt; SimpleServerService simpleServerService = new SimpleServerService(); //这个是&lt;port name=&quot;SimpleServerPort&quot; SimpleServer simpleServer = simpleServerService.getSimpleServerPort(); System.out.println(simpleServer.sayHello()); &#125; 1&#125; 通过jdk生成的SimpleServer，可以调用相应的方法，实际上返回响应的是服务器，但执行的时候就像调用自己写的类一样。可以清楚的看到方法和参数。 另一种调用的方式，直接使用java方法，不生成类： 新建一个other包，存放如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package simple.other;import javax.jws.WebMethod;import javax.jws.WebParam;import javax.jws.WebService;import javax.xml.bind.annotation.XmlSeeAlso;import javax.xml.ws.RequestWrapper;import javax.xml.ws.ResponseWrapper;//对应xml文件//&lt;definitions targetNamespace=&quot;http://server.simple/&quot; name=&quot;SimpleServerService&quot;&gt;@WebService(name = &quot;SimpleServerService&quot;, targetNamespace = &quot;http://server.simple/&quot;)@XmlSeeAlso(&#123;&#125;)public interface MySimpleClient &#123; @WebMethod @RequestWrapper(localName = &quot;sayHello&quot;) @ResponseWrapper(localName = &quot;sayHelloResponse&quot;) public String sayHello(); @WebMethod @RequestWrapper(localName = &quot;speak&quot;) @ResponseWrapper(localName = &quot;speakResponse&quot;) public String speak(@WebParam(name = &quot;word&quot;)String word);&#125; 测试代码： 123456789101112131415161718192021package simple.other;import javax.xml.namespace.QName;import javax.xml.ws.Service;import java.net.URL;public class OtherTest &#123; public static void main(String[] args) throws Exception &#123; URL wsdlUrl = new URL(&quot;http://localhost:9001/SimpleService?wsdl&quot;); // targetNamespace=&quot;http://server.simple/&quot; name=&quot;SimpleServerService&quot; Service s = Service.create(wsdlUrl, 123 new QName(&quot;http://server.simple/&quot;,&quot;SimpleServerService&quot;));MySimpleClient client = 1s.getPort( 1new QName(&quot;http://server.simple/&quot;, 1&quot;SimpleServerPort&quot;), 123456789 MySimpleClient.class); System.out.println(client.sayHello()); System.out.println(client.speak(&quot;123&quot;)); &#125;&#125; 2. cxf发布WebServiceJAX-WS是一种规范，CXF是他的实现。CXF可以不必关心服务端的实现方式。 为了简化代码，我们把服务端和客户端写在一个工程里，正常应该写在两个工程 2.1 发布服务新建web工程，导入jar包： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf.karaf&lt;/groupId&gt; &lt;artifactId&gt;apache-cxf&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志文件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CXF发布服务需要一个接口和一个实现类： 123456789101112131415161718192021package server;import javax.jws.WebParam;import javax.jws.WebService;@WebService(name = &quot;CXF&quot;, targetNamespace = &quot;http://server.cxf/&quot;)public interface CxfServer &#123; String sayHello(); String speak(@WebParam(name = &quot;word&quot;) String world);&#125; 实现类： 12345678910111213141516171819202122232425package server;public class CxfServerImpl implements CxfServer &#123; @Override public String sayHello() &#123; return &quot;Hello CXF&quot;; &#125; @Override public String speak(String word) &#123; return word + &quot;CXF&quot;; &#125;&#125; 发布服务： 123456789101112131415161718192021222324252627282930313233343536373839package server;import org.apache.cxf.jaxws.JaxWsServerFactoryBean;public class CXFServerTest &#123; public static void main(String[] args) &#123; // 创建JaxWsServerFactoryBean对象 JaxWsServerFactoryBean serverFactoryBean = new JaxWsServerFactoryBean(); // 设置服务端地址 serverFactoryBean.setAddress(&quot;http://127.0.0.1:9999/cxf&quot;); // 设置服务接口 serverFactoryBean.setServiceClass(CxfServer.class); // 设置实现类对象 serverFactoryBean.setServiceBean(new CxfServerImpl()); // 发布服务 serverFactoryBean.create(); System.out.println(&quot;发布成功&quot;); &#125;&#125; 浏览器中访问：http://127.0.0.1:9999/cxf?wsdl 2.2 调用服务123456789101112131415package client;import org.apache.cxf.endpoint.Client;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class CxfClientTest &#123; public static void main(String[] args) throws Exception &#123; JaxWsDynamicClientFactory clientFactory = 1234567891011121314151617 JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient(&quot;http://127.0.0.1:9999/cxf?wsdl&quot;); //直接调用方法，不用关心服务端是怎么实现的 Object[] result = client.invoke(&quot;sayHello&quot;); System.out.println(result[0]); Object[] result2 = client.invoke(&quot;speak&quot;, &quot;123&quot;); System.out.println(result2[0]); &#125;&#125; 2.3 Spring与CXF集成引入spring的jar 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring-cxf.xml配置 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot;http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsdhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--发布服务implementor是接口实现类，address在访问的时候加载路径里--&gt; &lt;jaxws:endpoint id=&quot;cxfDemo&quot; implementor=&quot;server.CxfServerImpl&quot; address=&quot;/cxf&quot;/&gt;&lt;/beans&gt; web.xml中配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-cxf.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 使用spring发布的时候，在接口实现类上加上注解，保证发布出去的targetNamespace一致： 123@WebService(name = &quot;CXF&quot;, targetNamespace = &quot;http://server.cxf/&quot;)public class CxfServerImpl implements CxfServer &#123; 浏览器中访问：http://127.0.0.1:8080/services/cxf?wsdl 测试方法与2.2中相同，更换访问地址即可。","categories":[{"name":"服务","slug":"服务","permalink":"https://zymmx.github.io/categories/服务/"}],"tags":[{"name":"webservice","slug":"webservice","permalink":"https://zymmx.github.io/tags/webservice/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-21T03:29:27.140Z","updated":"2018-11-21T03:29:27.140Z","comments":true,"path":"2018/11/21/hello-world/","link":"","permalink":"https://zymmx.github.io/2018/11/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}