{"meta":{"title":"木木夕","subtitle":null,"description":"如梦江湖 如戏人生","author":"木木夕","url":"https://zymmx.github.io"},"pages":[{"title":"404","date":"2018-11-21T06:39:09.000Z","updated":"2018-11-21T06:39:09.237Z","comments":true,"path":"404/index.html","permalink":"https://zymmx.github.io/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-21T06:38:53.000Z","updated":"2018-11-21T06:38:53.349Z","comments":true,"path":"search/index.html","permalink":"https://zymmx.github.io/search/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-21T15:03:42.000Z","updated":"2018-11-23T10:20:35.233Z","comments":true,"path":"about/index.html","permalink":"https://zymmx.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-21T08:14:18.642Z","updated":"2018-11-21T08:14:18.642Z","comments":true,"path":"tags/index.html","permalink":"https://zymmx.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-21T15:00:49.764Z","updated":"2018-11-21T08:14:18.642Z","comments":true,"path":"categories/index.html","permalink":"https://zymmx.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring详解","slug":"Spring","date":"2018-12-04T10:33:02.597Z","updated":"2018-12-04T11:06:40.755Z","comments":true,"path":"2018/12/04/Spring/","link":"","permalink":"https://zymmx.github.io/2018/12/04/Spring/","excerpt":"","text":"Spring一、什么是springSpring框架，由Rod Johnson开发 Spring是一个非常活跃的开源框架, 基于IOC和AOP来构架多层JavaEE系统，以帮助分离项目组件之间的依赖关系 二、核心概念IoC：Inversion of Control 控制反转 DI：Dependency Injection,依赖注入 AOP：Aspect Oriented Programming 面向切面编程 三、Spring的组成Spring框架包含的功能大约由20个模块组成。这些模块按组可分为核心容器、数据访问/集成，Web，AOP(面向切面编程)、设备、消息和测试 核心模块：Beans、Core、Context、SpEL对应四个初始化项目时需要的四个核心包 四、模块介绍 GroupId ArtifactId 说明 org.springframework spring-beans Beans 支持，包含 Groovy org.springframework spring-aop 基于代理的AOP支持 org.springframework spring-aspects 基于AspectJ 的切面 org.springframework spring-context 应用上下文运行时，包括调度和远程抽象 org.springframework spring-context-support 支持将常见的第三方类库集成到 Spring 应用上下文 org.springframework spring-core 其他模块所依赖的核心模块 org.springframework spring-expression Spring 表达式语言，SpEL org.springframework spring-instrument JVM 引导的仪表（监测器）代理 org.springframework spring-instrument-tomcat Tomcat 的仪表（监测器）代理 org.springframework spring-jdbc 支持包括数据源设置和 JDBC 访问支持 org.springframework spring-jms 支持包括发送/接收JMS消息的助手类 org.springframework spring-messaging 对消息架构和协议的支持 org.springframework spring-orm 对象/关系映射，包括对 JPA 和 Hibernate 的支持 org.springframework spring-oxm 对象/XML 映射（Object/XML Mapping，OXM） org.springframework spring-test 单元测试和集成测试支持组件 org.springframework spring-tx 事务基础组件，包括对 DAO 的支持及 JCA 的集成 org.springframework spring-web web支持包，包括客户端及web远程调用 org.springframework spring-webmvc REST web 服务及 web 应用的 MVC 实现 org.springframework spring-webmvc-portlet 用于 Portlet 环境的MVC实现 org.springframework spring-websocket WebSocket 和 SockJS 实现，包括对 STOMP 的支持 五、模块详解1、core - 核心模块 spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-context-support spring-expression：spring表达式语言 核心模块说明 （1）spring-core 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类 （2）spring-beans 这个jar文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI支持，引入spring-core.jar及spring- beans.jar文件就可以了 （3）spring-context Spring核心提供了大量扩展，这样使得由 Core 和 Beans 提供的基础功能增强：这意味着Spring 工程能以框架模式访问对象。Context 模块继承了Beans 模块的特性并增加了对国际化（例如资源绑定）、事件传播、资源加载和context 透明化（例如 Servlet container）。同时，也支持JAVA EE 特性，例如 EJB、 JMX 和 基本的远程访问。Context 模块的关键是 ApplicationContext 接口。spring-context-support 则提供了对第三方库集成到 Spring-context 的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。 （4）spring-expression 为在运行时查询和操作对象图提供了强大的表达式语言。它是JSP2.1规范中定义的统一表达式语言的扩展，支持 set 和 get 属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。 2、Data Access/Integration - 数据访问与集成 数据访问与集成层包含 JDBC、ORM、OXM、JMS和事务模块。 详细说明 （1）spring-jdbc 提供了 JDBC抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析。 （2）spring-tx 支持编程式事务和声明式事务，可用于实现了特定接口的类和所有的 POJO 对象。编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细。 （3）spring-orm 提供了对流行的对象关系映射 API的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring 的其它功能整合，比如前面提及的事务管理。 （4）spring-oxm 模块提供了对 OXM 实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。 （5）spring-jms 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了 spring-messaging 模块 3、Web Web 层包括 spring-web、spring-webmvc、spring-websocket、spring-webmvc-portlet 等模块。 详细说明 （1）spring-web 提供面向 web 的基本功能和面向 web 的应用上下文，比如 multipart 文件上传功能、使用 Servlet 监听器初始化 IoC 容器等。它还包括 HTTP 客户端以及 Spring 远程调用中与 web 相关的部分 （2）spring-webmvc 为 web 应用提供了模型视图控制（MVC）和 REST Web 服务的实现。Spring 的 MVC 框架可以使领域模型代码和 web 表单完全地分离，且可以与 Spring 框架的其它所有功能进行集成 （3）spring-webmvc-portlet （即Web-Portlet模块）提供了用于 Portlet 环境的 MVC 实现，并反映了 pring-webmvc 模块的功能 4、AOP （1）spring-aop 提供了面向切面编程（AOP）的实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦。使用源码级的元数据。 （2）spring-aspects 提供了对 AspectJ 的集成 5、Instrumentation （1）spring-instrument 模块提供了对检测类的支持和用于特定的应用服务器的类加载器的实现。 （2）spring-instrument-tomcat 模块包含了用于 Tomcat 的Spring 检测代理。 6、Messaging - 消息处理 spring-messaging 模块 从 Spring 4 开始集成，从一些 Spring 集成项目的关键抽象中提取出来的。这些项目包括 Message、MessageChannel、MessageHandler 和其它服务于消息处理的项目。这个模块也包含一系列的注解用于映射消息到方法 7、Test spring-test 模块 通过 JUnit 和 TestNG 组件支持单元测试和集成测试。它提供了一致性地加载和缓存 Spring 上下文，也提供了用于单独测试代码的模拟对象（mock object） 六、入门程序和IOC1、下载 Spring框架的主页：http://spring.io/ 下载地址：http://repo.spring.io/release/org/springframework/spring 2、创建项目 spring-01-IOC java项目或maven项目 3、引入jar包 核心包加日志包 12345678910111213pom:&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 4、引入log4j.properties 放入源码目录（maven项目放在src/mian/resources下） 5、创建一个类 12345678910package name.yaohuan.spring.bean;public class Person &#123; private String name; private Integer age; public Person() &#123; super(); System.out.println(&quot;Person的空参构造方法&quot;); &#125; //getter、setter、空参构造、toString&#125; 6、创建配置文件 配置文件的位置和名字可以自定义，但是建议放在src下，名字为applicationContext.xml 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 也可以安装spring的sts插件 7、配置bean对象 在配置文件中添加bean的配置，让spring管理对象的创建 1&lt;bean name=&quot;person&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 说明： bean元素：素描述需要spring容器管理的对象。 class属性：被管理对象的完整类名。 name属性：给被管理的对象起个名字，根据该名称获得对象。 8、测试 12345678910111213141516package name.yaohuan.spring.bean;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class IOCTest &#123; @Test public void testCreatePerson()&#123; //1、创建容器对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //2、在容器中找到person对象 Person p = (Person)context.getBean(&quot;person&quot;); //3、打印 System.out.println(p); &#125;&#125; 七、什么是IoCIoC-控制反转 IoC是 Inverse of Control 的简写，意思是控制反转。是降低对象之间的耦合关系的设计思想。 通过IOC，开发人员不需要关心对象的创建过程，交给Spring容器完成。具体的过程是，程序读取Spring 配置文件，获取需要创建的 bean 对象， 通过反射机制创建对象的实例。 缺点：对象是通过反射机制实例化出来的，因此对系统的性能有一定的影响。 DI-依赖注入 Dependency Injection，说的是创建对象实例时，同时为这个对象注入它所依赖的属性。相当于把每个bean与bean之间的关系交给容器管理。而这个容器就是spring。 例如我们通常在 Service 层注入它所依赖的 Dao 层的实例；在 Controller层注入 Service层的实例。 IoC和DI IoC的别名,2004年，Martin Fowler探讨了同一个问题，既然IoC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理对象变为由IoC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection，DI）”。他的这个答案，实际上给出了实现IoC的方法：注入。 所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。 所以，依赖注入（DI）和控制反转（IoC）是从不同的角度描述的同一件事情，就是指通过引入IoC容器，利用依赖关系注入的方式，实现对象之间的解耦 八、对象创建的细节applicationContext-bean.xml BeanTest.java 一、bean元素的id和name bean元素既可以定义name属性，也可以定义id属性 name属性：可以重复，可以使用特殊字符。id属性：作用与name属性一样。名称不可重复，不能使用特殊字符。 1&lt;bean id=&quot;person1&quot; name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 以下两种方式都可以获取到上面的Person对象 123456@Test public void testCreatePerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); Person p1 = (Person)context.getBean(&quot;person1&quot;);//方式1 Person p2= (Person)context.getBean(&quot;person2&quot;);//方式2 &#125; 二、创建对象的工厂 1、FileSystemXmlApplicationContext：从硬盘绝对路径下加载配置文件 1234@Testpublic void testBeanFactory1()&#123; ApplicationContext context = new FileSystemXmlApplicationContext(&quot;D:\\\\workspace\\\\spring-01-IOC\\\\src\\\\applicationContext-bean.xml&quot;);&#125; 2、ClassPathXmlApplicationContext：丛类路径下加载配置文件 1234@Test public void testBeanFactory2()&#123; ApplicationContext context2 = new ClassPathXmlApplicationContext(&quot;applicationContextbean-bean.xml&quot;); &#125; 通过上面的测试也可以发现，默认情况下，每次容器启动时就会创建容器中配置的所有对象 三、单例和多例 为bean配置scope属性 1、scope=”singleton”，单例， 默认值， 适用实际开发中的绝大部分情况 1&lt;bean name=&quot;person&quot; scope=&quot;singleton&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 1234567@Test public void testScope()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); Person p1 = (Person)context.getBean(&quot;person&quot;); Person p2 = (Person)context.getBean(&quot;person&quot;); System.out.println(p1==p2); //true &#125; 2、scope=”prototype”，多例，适用于struts2中的action的配置 1&lt;bean name=&quot;person&quot; scope=&quot;prototype&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 1234567@Test public void testScope()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); Person p1 = (Person)context.getBean(&quot;person&quot;); Person p2 = (Person)context.getBean(&quot;person&quot;); System.out.println(p1==p2); //false &#125; 3、scope=“request”（了解）：web环境下，对象与request生命周期一致。很少用。 4、scope=“session”（了解）：web环境下，对象与session生命周期一致。很少用。 四、对象创建的时机 scope=”singleton” 在启动容器时， 创建bean，且整个应用只有一个。 scope=”prototype” 在用到对象的时候，才创建对象。每次创建都是新的对象。 五、是否延迟创建 注意：只对单例有效，设置scope=”singleton”时测试 lazy-init=”false” 默认值，不延迟创建，即在启动时候就创建对象 lazy-init=”true” 延迟初始化， 在用到对象的时候才创建对象 1&lt;bean name=&quot;person&quot; scope=&quot;singleton&quot; lazy-init=&quot;true&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 123456@Test public void testLazy()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); //lazy-init=&quot;true&quot;，则直到执行下面的语句对象才会被创建 Person p = (Person)context.getBean(&quot;person&quot;); &#125; 六、初始化/销毁 init-method=”init” 对应对象的init()方法，在对象创建之后执行 destroy-method=”destroy” 调用容器对象的destroy()方法时候执行 在Person类中添加初始化方法和销毁方法： 1234567public void init() &#123; System.out.println(&quot;Person的初始化方法&quot;); &#125; public void destroy() &#123; System.out.println(&quot;Person的销毁方法&quot;); &#125; 配置bean： 1&lt;bean name=&quot;person&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt;&lt;/bean&gt; 测试： 注意：单实例时测试 123456789@Test public void testInitAndDestroy()&#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-bean.xml&quot;); //或者手动调用销毁方法 context.destroy(); //或者关闭容器，触发销毁方法 //context.close(); &#125; 九、对象创建的几种方式applicationContext-create.xml CreateTest.java 一、无参构造函数 前面的方式调用了类的无参构造函数 二、有参构造函数 参考后面章节的：对象的依赖-属性注入（构造函数注入） 三、静态工厂方法 创建工厂类： 12345678package name.yaohuan.spring.factory;import name.yaohuan.spring.bean.Person;public class PersonFactory &#123; public static Person createPerson1()&#123; System.out.println(&quot;静态工厂创建Person&quot;); return new Person(); &#125;&#125; 配置bean： 12&lt;!-- 静态工厂创建 --&gt;&lt;bean name=&quot;person1&quot; class=&quot;name.yaohuan.spring.factory.PersonFactory&quot; factory-method=&quot;createPerson1&quot;&gt;&lt;/bean&gt; 测试： 容器初始化的时候同时调用静态工厂初始化了对象 1234@Test public void testCreatePerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-create.xml&quot;); &#125; 四、实例工厂 在上一步的工厂类中添加实例工厂方法： 1234public Person createPerson2()&#123; System.out.println(&quot;实例工厂创建Person&quot;); return new Person();&#125; 配置bean： 123&lt;!-- 实例工厂创建 --&gt;&lt;bean name=&quot;personFactory&quot; class=&quot;name.yaohuan.spring.factory.PersonFactory&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;person2&quot; factory-bean=&quot;personFactory&quot; factory-method=&quot;createPerson2&quot;&gt;&lt;/bean&gt; 测试： 使用上一步的测试用例即可 十、对象的依赖关系-依赖注入applicationContext-injection.xmlInjectionTest.java 一、set方法注入 1、值类型注入使用 value 配置bean： 12345&lt;!-- set注入 --&gt;&lt;bean name=&quot;person1&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;helen&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 1234567@Test public void testProperty()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person1&quot;); System.out.println(p); &#125; 在Person中添加 toString() 方法 结果： 2、引用类型注入使用 ref 创建Car.java： 1234567891011package name.yaohuan.spring.bean;public class Car &#123; private String name; private String color; public Car() &#123; super(); System.out.println(&quot;Car的空参构造方法&quot;); &#125; //getter、setter、toString&#125; 在Person中引用Car： 123456public class Person &#123; private String name; private Integer age; private Car car; //getter、setter、toString等&#125; 配置bean： 12345678910&lt;bean name=&quot;person1&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;helen&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name=&quot;car&quot; class=&quot;name.yaohuan.spring.bean.Car&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;MINI&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;灰色&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 测试： 1234567@Test public void testProperty()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person1&quot;); System.out.println(p); &#125; 测试：使用上一步的测试用例即可 二、构造函数注入 1、name属性：按参数名注入 在Person中创建构造函数： 123456public Person(String name, Car car) &#123; super(); System.out.println(&quot;Person(String name, Car car)&quot;); this.name = name; this.car = car; &#125; 配置bean：使用 name 属性指定参数名 1234&lt;bean name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;helen&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 测试： 123456@Test public void testConstuctor()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person2&quot;); System.out.println(p); &#125; 结果： 2、index属性：按参数索引注入 参数名一致，但位置不一致时，使用 index 例如以下两个构造函数： 12345678910111213public Person(String name, Car car) &#123; super(); System.out.println(&quot;Person(String name, Car car)&quot;); this.name = name; this.car = car; &#125; public Person(Car car, String name) &#123; super(); System.out.println(&quot;Person(Car car, String name)&quot;); this.name = name; this.car = car; &#125; 配置bean，使用index确定调用哪个构造函数： 1234&lt;bean name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;helen&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 重新执行第一步的测试用例 结果： 3、type属性：按参数类型注入 参数名和位置一致，但类型不一致时，使用type 例如以下两个构造函数： 12345678910111213public Person(Car car, String name) &#123; super(); System.out.println(&quot;Person(Car car, String name)&quot;); this.name = name; this.car = car; &#125; public Person(Car car, Integer name) &#123; super(); System.out.println(&quot;Person(Car car, Integer name)&quot;); this.name = name + &quot;&quot;; this.car = car; &#125; 配置bean，使用type指定参数的类型 1234&lt;bean name=&quot;person2&quot; class=&quot;name.yaohuan.spring.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;988&quot; type=&quot;java.lang.Integer&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car&quot; &gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 重新执行第一步的测试用例 结果： 三、p名称空间注入 导入p名称空间 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 使用 p:属性名 完成注入，走set方法 值类型：p:属性名=”值” 对象类型：p:属性名-ref=”bean名称” 12&lt;bean name=&quot;person3&quot; class=&quot;name.yaohuan.spring.bean.Person&quot; p:name=&quot;helen&quot; p:age=&quot;18&quot; p:car-ref=&quot;car&quot;&gt;&lt;/bean&gt; 测试： 123456@Test public void testP()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person3&quot;); System.out.println(p); &#125; 结果： 四、spel注入 spring Expression Language：spring表达式语言 bean配置 12345&lt;bean name=&quot;person4&quot; class=&quot;name.yaohuan.spring.bean.Person&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;person1.name&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;#&#123;person1.age&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 测试： 123456@Test public void testSpel()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext-injection.xml&quot;); Person p = (Person)context.getBean(&quot;person4&quot;); System.out.println(p); &#125; 结果： 十一、对象的依赖关系-复杂类型注入applicationContext-collection.xml CollectionTest.java 实体类： 123456789101112package name.yaohuan.spring.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Properties;public class CollectionBean &#123; private Object[] arr;//数组类型注入 private List list;//list/set 类型注入 private Map map;//map类型注入 private Properties prop;//properties类型注入 //getter、setter、空参构造、toString&#125; 一、数组注入 1、如果数组中只准备注入一个 值 | 对象，直接使用 value | ref 即可 1234567891011&lt;bean name=&quot;car&quot; class=&quot;name.yaohuan.spring.bean.Car&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;MINI&quot;&gt;&lt;/property&gt; &lt;property name=&quot;color&quot; value=&quot;灰色&quot; &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 数组注入 --&gt; &lt;bean name=&quot;cb1&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;!-- 如果数组中只准备注入一个值(对象)，直接使用value|ref即可 --&gt; &lt;property name=&quot;arr&quot; value=&quot;helen&quot; &gt;&lt;/property&gt; &lt;!-- &lt;property name=&quot;arr&quot; ref=&quot;car&quot; &gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 2、多个数组元素 12345678910&lt;bean name=&quot;cb2&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;!-- array注入,多个元素注入 --&gt; &lt;property name=&quot;arr&quot;&gt; &lt;array&gt; &lt;value&gt;tom&lt;/value&gt; &lt;value&gt;helen&lt;/value&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 二、List注入 1、如果集合中只准备注入一个值(对象),直接使用value|ref即可 1234&lt;bean name=&quot;cb3&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;!-- 如果List中只准备注入一个值(对象),直接使用value|ref即可 --&gt; &lt;property name=&quot;list&quot; value=&quot;helen&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 2、多个集合元素 123456789&lt;bean name=&quot;cb4&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;property name=&quot;list&quot; &gt; &lt;list&gt; &lt;value&gt;helen&lt;/value&gt; &lt;value&gt;rose&lt;/value&gt; &lt;ref bean=&quot;car&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 三、Map注入 123456789&lt;bean name=&quot;cb5&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;property name=&quot;map&quot; &gt; &lt;map&gt; &lt;entry key=&quot;username&quot; value=&quot;root&quot; &gt;&lt;/entry&gt; &lt;entry key=&quot;car&quot; value-ref=&quot;car&quot; &gt;&lt;/entry&gt; &lt;entry key-ref=&quot;car&quot; value-ref=&quot;car&quot; &gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 四、properties类型注入 123456789&lt;bean name=&quot;cb6&quot; class=&quot;name.yaohuan.spring.bean.CollectionBean&quot; &gt; &lt;property name=&quot;prop&quot;&gt; &lt;props&gt; &lt;prop key=&quot;driverClass&quot;&gt;com.jdbc.mysql.Driver&lt;/prop&gt; &lt;prop key=&quot;userName&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 十二、使用注解1、创建项目 spring-02-annotation 2、引入jar包 核心包加日志包（和之前一样） 加 spring-aop 包 maven项目无需添加新包，context依赖了aop。完整的依赖如下： 123456789101112&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、创建实体类 Person.java：保留基本空参构造方法和getter、setter即可 Car.java 5、创建applicationContext.xml 引入新的名称空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;&lt;/beans&gt; 6、配置注解扫描 指定扫描name.yaohuan.spring.bean下的所有类中的注解。 扫描包时，会扫描所有子孙包 1&lt;context:component-scan base-package=&quot;name.yaohuan.spring.bean&quot;&gt;&lt;/context:component-scan&gt; 7、在类中使用注解 123@Component(&quot;person&quot;)//&lt;bean name=&quot;person&quot; class=&quot;name.yaohuan.spring.bean.Person&quot; /&gt;public class Person &#123; 8、测试 123456789public class AnnotationTest &#123; @Test public void testCreatePerson()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Person p = (Person)context.getBean(&quot;person&quot;); System.out.println(p); &#125; &#125; 9、其他类的头部可用的注解 123@Service(&quot;person&quot;) // service层@Controller(&quot;person&quot;) // controller层@Repository(&quot;person&quot;)// dao层 10、在类的头部指定对象的作用域 12@Scope(scopeName=&quot;singleton&quot;)@Scope(scopeName=&quot;prototype&quot;) 11、注入属性value值 加在成员变量上：通过反射的Field赋值（破坏对象的封装性） 12@Value(&quot;helen&quot;) private String name; 或加在set方法上：通过set方法赋值 1234@Value(&quot;tom&quot;) public void setName(String name) &#123; this.name = name; &#125; @Value(“helen”) 等同于 @Value(value=”helen”) 12、自动装配 （1）@Autowired 1234567@Component(&quot;car&quot;)public class Car &#123; @Value(&quot;mini&quot;) private String name; @Value(&quot;红&quot;) private String color;&#125; 123456789@Component(&quot;person&quot;)public class Person &#123; @Value(&quot;helen&quot;) private String name; @Value(&quot;18&quot;) private Integer age; @Autowired private Car car;&#125; （2）@Qualifier 如果匹配多个类型一致的对象，将无法选择具体注入哪一个对象 使用@Qualifier()注解告诉spring容器自动装配哪个名称的对象 创建Computer接口和PC、Labtop实现类： 12public interface Computer &#123;&#125; 123456@Component(&quot;pc&quot;)public class PC implements Computer&#123; @Value(&quot;联想台式机&quot;) private String name; //getter、setter、空参构造、toString&#125; 123456@Component(&quot;labtop&quot;)public class Labtop implements Computer&#123; @Value(&quot;苹果笔记本&quot;) private String name; //getter、setter、空参构造、toString&#125; 在Person类中添加Computer属性：使用 @Qualifier(&quot;labtop&quot;) 指定装配 @Component(&quot;labtop&quot;) 对象 1234@Autowired @Qualifier(&quot;labtop&quot;) private Computer computer; //getter、setter （3）@Resource 使用@Resource指定注入哪个名称的对象 12@Resource(name=&quot;pc&quot;) private Computer computer; 13、初始化和销毁方法 注意：单实例时设置 person类： 123456789@PostConstruct //在对象被创建后调用，init-method public void init() &#123; System.out.println(&quot;Person的初始化方法&quot;); &#125; @PreDestroy //在销毁之前调用，destory-method public void destroy() &#123; System.out.println(&quot;Person的销毁方法&quot;); &#125; 测试： 12345678@Test public void testInitAndDestroy()&#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //或者手动调用销毁方法 context.destroy(); //或者关闭容器，触发销毁方法 //context.close(); &#125; 十三、spring整合junit测试spring整合junit，为我们提供了方便的测试方式 1、导包 在spring-02-annotation项目中再加入如下包 pom： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 完整的依赖如下： 1234567891011121314151617&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 2、创建测试类 12345678910111213//创建容器@RunWith(SpringJUnit4ClassRunner.class)//指定创建容器时使用哪个配置文件@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class RunWithTest &#123; //将名为user的对象注入到u变量中 @Resource(name=&quot;person&quot;) private Person p; @Test public void testCreatePerson()&#123; System.out.println(p); &#125;&#125; 十四、aop简介1、AOP （面向切面编程） 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP 思想：横向重复、纵向抽取 2、底层实现： Spring 的 AOP 的底层用到两种代理机制： JDK 的动态代理：针对实现了接口的类产生代理。 Cglib 的动态代理：针对没有实现接口的类产生代理，应用的是底层的字节码增强的技术 生成当前类的子类对象。 3、AOP 的开发中的相关术语： Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在 spring 中，这些点指的是方法,因为 spring 只支持方法类型的连接点（可以被切入的点） Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。（已经被切入的点） Advice（通知/增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能） Introduction（引介）：引介是一种特殊的通知在不修改类代码的前提下，Introduction 可以在运行期为类动态地添加一些方法或 Field。 Aspect（切面）：是切入点和通知（引介）的结合 Target（目标对象）：代理的目标对象 Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。 Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 十五、spring aop 开发（xml）1、创建项目 spring-03-aop 2、引入jar包 核心包加日志包（和之前一样） 测试包 再加入以下包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 完整的依赖如下： 12345678910111213141516171819202122&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、准备目标对象 先创建UserService接口： 1234567package name.yaohuan.spring.service;public interface UserService &#123; void save(); void delete(); void update(); void select();&#125; 实现类： 123456789101112131415161718192021222324package name.yaohuan.spring.service;public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(&quot;保存用户!&quot;); //int i = 1/0; &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户!&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新用户!&quot;); &#125; @Override public void select() &#123; System.out.println(&quot;查找用户!&quot;); &#125;&#125; 5、准备通知 123456789101112131415161718192021222324252627282930313233343536package name.yaohuan.spring.aop;import org.aspectj.lang.ProceedingJoinPoint;//通知类public class MyAdvice &#123; //前置通知：目标方法运行之前调用 //后置通知(如果出现异常不会调用)：在目标方法运行之后调用 //环绕通知：在目标方法之前和之后都调用 //异常拦截通知：如果出现异常，就会调用 //后置通知(无论是否出现 异常都会调用)：在目标方法运行之后调用 //前置通知 public void before()&#123; System.out.println(&quot;这是前置通知!!&quot;); &#125; //后置通知 public void afterReturning()&#123; System.out.println(&quot;这是后置通知(如果出现异常不会调用)!!&quot;); &#125; //环绕通知 public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;这是环绕通知之前的部分!!&quot;); Object proceed = pjp.proceed();//调用目标方法 System.out.println(&quot;这是环绕通知之后的部分!!&quot;); return proceed; &#125; //异常通知 public void afterException()&#123; System.out.println(&quot;出事啦!出现异常了!!&quot;); &#125; //后置通知 public void after()&#123; System.out.println(&quot;这是后置通知(出现异常也会调用)!!&quot;); &#125;&#125; 6、配置进行织入,将通知织入目标对象中 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd &quot;&gt;&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt; &lt;bean name=&quot;userService&quot; class=&quot;name.yaohuan.spring.service.UserServiceImpl&quot; &gt;&lt;/bean&gt;&lt;!-- 2.配置通知对象 --&gt; &lt;bean name=&quot;myAdvice&quot; class=&quot;name.yaohuan.spring.aop.MyAdvice&quot; &gt;&lt;/bean&gt;&lt;!-- 3.配置将通知织入目标对象 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点 public void name.yaohuan.spring.service.UserServiceImpl.save() * name.yaohuan.spring.service.UserServiceImpl.*() * name.yaohuan.spring.service.*ServiceImpl.*(..) * name.yaohuan.spring.service..*ServiceImpl.*(..) --&gt; &lt;aop:pointcut expression=&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot; id=&quot;pc&quot;/&gt; &lt;aop:aspect ref=&quot;myAdvice&quot; &gt; &lt;!-- 指定名为before方法作为前置通知 --&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pc&quot; /&gt; &lt;!-- 后置 --&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pc&quot; /&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;pc&quot; /&gt; &lt;!-- 异常拦截通知 --&gt; &lt;aop:after-throwing method=&quot;afterException&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;!-- 后置 --&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pc&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 7、测试 123456789101112131415161718package name.yaohuan.spring.service;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Resource(name=&quot;userService&quot;) private UserService userService; @Test public void testSave()&#123; userService.save(); &#125;&#125; 十六、spring aop 开发（注解）1、按照前面的步骤中准备目标对象和通知 2、配置文件 配置目标对象 配置通知对象 开启注解 12&lt;!-- 3.开启使用注解完成织入 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 7、MyAdvice中加注解 123456789101112131415161718192021222324252627282930313233343536//通知类@Aspect//表示该类是一个通知类public class MyAdvice &#123; @Pointcut(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void pc()&#123;&#125; //前置通知 //指定该方法是前置通知,并制定切入点 @Before(&quot;MyAdvice.pc()&quot;) public void before()&#123; System.out.println(&quot;这是前置通知!!&quot;); &#125; //后置通知 @AfterReturning(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void afterReturning()&#123; System.out.println(&quot;这是后置通知(如果出现异常不会调用)!!&quot;); &#125; //环绕通知 @Around(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;这是环绕通知之前的部分!!&quot;); Object proceed = pjp.proceed();//调用目标方法 System.out.println(&quot;这是环绕通知之后的部分!!&quot;); return proceed; &#125; //异常通知 @AfterThrowing(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void afterException()&#123; System.out.println(&quot;出事啦!出现异常了!!&quot;); &#125; //后置通知 @After(&quot;execution(* name.yaohuan.spring.service.*ServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;这是后置通知(出现异常也会调用)!!&quot;); &#125;&#125; 十七、JdbcTemplate入门类似DBUtils 的 QueryRunner 案例：救援系统的角色表的增删改查 1、创建项目 spring-04-jdbcTemplate 2、导包 核心包加日志包（和之前一样） 测试包 再加入以下jar包 完整的依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、数据库 新建数据库spring，创建角色表 12345678910111213/*Table structure for table `ar_role` */CREATE TABLE `ar_role` ( `rid` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;角色id&apos;, `rname` varchar(20) NOT NULL COMMENT &apos;角色名&apos;, `alias` varchar(20) NOT NULL COMMENT &apos;角色别名&apos;, PRIMARY KEY (`rid`)) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;/*Data for the table `ar_role` */insert into `ar_role`(`rid`,`rname`,`alias`) values (1,&apos;administrator&apos;,&apos;系统管理员&apos;);insert into `ar_role`(`rid`,`rname`,`alias`) values (2,&apos;dispatcher&apos;,&apos;调度员&apos;); 5、拷贝之前写的 DataSourceUtil.java 6、拷贝c3p0-config.xml 7、写测试类 下面是不使用 DataSourceUtil.java 的版本，和使用 DataSourceUtil.java 的版本 12345678910111213141516171819202122232425262728293031323334353637383940package name.yaohuan.spring.jdbctemplate;public class JdbcTemplateTest &#123; //不使用工具类 @Test public void testSave1() throws PropertyVetoException&#123; //准备连接池 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/spring&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;123456&quot;); //创建JdbcTemplate对象 JdbcTemplate jt= new JdbcTemplate(dataSource); //执行sql String sql = &quot; INSERT INTO ar_role ( &quot; + &quot; rname,&quot; + &quot; alias&quot; + &quot; ) VALUES (?,?)&quot; ; jt.update(sql, &quot;test1&quot;, &quot;test1&quot;); &#125; //使用工具类 @Test public void testSave2() throws PropertyVetoException&#123; //准备连接池 DataSource dataSource = DataSourceUtil.getDataSource(); //创建JdbcTemplate对象 JdbcTemplate jt= new JdbcTemplate(dataSource); //执行sql String sql = &quot; INSERT INTO ar_role ( &quot; + &quot; rname,&quot; + &quot; alias&quot; + &quot; ) VALUES (?,?)&quot; ; jt.update(sql, &quot;test2&quot;, &quot;test2&quot;); &#125;&#125; 十八、用spring管理JdbcTemplate学习JdbcTemplate API 和 如何用Spring 管理 JdbcTemplate 1、创建 pojo.Role.java 123456package name.yaohuan.spring.pojo;public class Role &#123; private Integer rid; private String rname; private String alias;&#125; 2、创建 dao.RoleDao.java 和 dao.RoleDaoImpl.java 123456789101112131415package name.yaohuan.spring.dao;public interface RoleDao &#123; //增 void save(Role role); //删 void delete(Integer id); //改 void update(Role role); //查 Role getById(Integer id); //查 int getTotalCount(); //查 List&lt;Role&gt; getAll();&#125; 将数据源（连接池）、JdbcTemplate、RoleDao对象交给spring容器管理 如果不用注解的方式配置，不要忘记写jt的 set 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package name.yaohuan.spring.dao;public class RoleDaoImpl extends JdbcDaoSupport implements RoleDao &#123; private JdbcTemplate jt; public void setJt(JdbcTemplate jt) &#123; this.jt = jt; &#125; @Override public void save(Role role) &#123; String sql = &quot; INSERT INTO ar_role ( &quot; + &quot; rname,&quot; + &quot; alias&quot; + &quot; ) VALUES (?,?)&quot; ; jt.update(sql, role.getRname(), role.getAlias()); &#125; @Override public void delete(Integer id) &#123; String sql = &quot;delete from ar_role where rid = ? &quot;; jt.update(sql, id); &#125; @Override public void update(Role role) &#123; String sql = &quot;update ar_role set rname = ?, alias = ? where rid=? &quot;; jt.update(sql, role.getRname(), role.getAlias(), role.getRid()); &#125; @Override public Role getById(Integer id) &#123; String sql = &quot;select * from ar_role where rid = ? &quot;; return jt.queryForObject(sql,new RowMapper&lt;Role&gt;()&#123; @Override public Role mapRow(ResultSet rs, int index) throws SQLException &#123; return mapRowHandler(rs); &#125;&#125;, id); &#125; @Override public int getTotalCount() &#123; String sql = &quot;select count(*) from ar_role &quot;; Integer count = jt.queryForObject(sql, Integer.class); return count; &#125; @Override public List&lt;Role&gt; getAll() &#123; String sql = &quot;select * from ar_role&quot;; List&lt;Role&gt; list = jt.query(sql, new RowMapper&lt;Role&gt;()&#123; @Override public Role mapRow(ResultSet rs, int index) throws SQLException &#123; return mapRowHandler(rs); &#125;&#125;); return list; &#125; private Role mapRowHandler(ResultSet rs) throws SQLException &#123; Role role = new Role(); role.setRname(rs.getString(&quot;rname&quot;)); role.setAlias(rs.getString(&quot;alias&quot;)); role.setRid(rs.getInt(&quot;rid&quot;)); return role; &#125;&#125; 3、创建db.properties 1234jdbc.jdbcUrl=jdbc:mysql://localhost:3306/springjdbc.driverClass=com.mysql.jdbc.Driverjdbc.user=rootjdbc.password=123456 4、配置applicationContext.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 1、连接池 --&gt;&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; &gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2、JdbcTemplate --&gt;&lt;bean name=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、roleDao --&gt;&lt;bean name=&quot;roleDao&quot; class=&quot;name.yaohuan.spring.dao.RoleDaoImpl&quot; &gt; &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplate&quot; &gt;&lt;/property&gt;&lt;/bean&gt; &lt;/beans&gt; 5、写测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package name.yaohuan.spring.jdbctemplate;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class SpringJdbcTemplateTest &#123; @Resource(name=&quot;roleDao&quot;) private RoleDao roleDao; @Test public void testSave() throws Exception&#123; Role role = new Role(); role.setRname(&quot;spring1&quot;); role.setAlias(&quot;spring1&quot;); roleDao.save(role); &#125; @Test public void testDelete() throws Exception&#123; roleDao.delete(11); &#125; @Test public void testUpdate() throws Exception&#123; Role role = new Role(); role.setRid(10); role.setRname(&quot;spring123&quot;); role.setAlias(&quot;spring123&quot;); roleDao.update(role); &#125; @Test public void testGetById() throws Exception&#123; System.out.println(roleDao.getById(1)); &#125; @Test public void testGetTotalCount() throws Exception&#123; System.out.println(roleDao.getTotalCount()); &#125; @Test public void testGetAll() throws Exception&#123; System.out.println(roleDao.getAll()); &#125;&#125; 6、也可以使用注解的方式 （1）在applicationContext中配置注解扫描 1&lt;context:component-scan base-package=&quot;name.yaohuan.spring.dao&quot;&gt;&lt;/context:component-scan&gt; （2）不用配置 &lt;bean name=”roleDao” … （3）在 RoleDaoImpl中配置注解 此时已经不需要 jt 的 set 方法 12345@Repository(&quot;roleDao&quot;)public class RoleDaoImpl implements RoleDao &#123; @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jt; （4）执行刚才的测试用例即可 十九、转账的案例（无事务）案例：转账 1、创建项目 spring-05-tx 2、导包 同 前一个项目 spring-04-jdbcTemplate，再加上aop的相关包 完整的依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.40&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; 3、引入日志配置 log4j.properties 4、复制数据库配置 db.properties 5、创建数据库表 在spring数据库中创建 12345678910111213/*Table structure for table `ar_account` */CREATE TABLE `ar_account` ( `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, `username` VARCHAR(20) NOT NULL, `money` DECIMAL(10,2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;/*Data for the table `ar_account` */INSERT INTO `ar_account`(`id`,`username`,`money`) VALUES (1,&apos;Helen&apos;,&apos;1000.00&apos;);INSERT INTO `ar_account`(`id`,`username`,`money`) VALUES (2,&apos;Tom&apos;,&apos;1000.00&apos;); 6、创建dao接口和dao 1234567package name.yaohuan.spring.dao;public interface AccountDao &#123; //加钱 void increaseMoney(Integer id,Double money); //减钱 void decreaseMoney(Integer id,Double money);&#125; 123456789101112131415package name.yaohuan.spring.dao;@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jt; @Override public void increaseMoney(Integer id, Double money) &#123; jt.update(&quot;update ar_account set money = money+? where id = ? &quot;, money,id); &#125; @Override public void decreaseMoney(Integer id, Double money) &#123; jt.update(&quot;update ar_account set money = money-? where id = ? &quot;, money,id); &#125;&#125; 7、创建service接口和service 12345package name.yaohuan.spring.service;public interface AccountService &#123; //转账方法 void transfer(Integer from, Integer to, Double money);&#125; 123456789101112131415package name.yaohuan.spring.service;@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService &#123; @Resource(name=&quot;accountDao&quot;) private AccountDao accountDao ; @Override public void transfer(final Integer from,final Integer to,final Double money) &#123; //减钱 accountDao.decreaseMoney(from, money); int i = 1/0; //异常 //加钱 accountDao.increaseMoney(to, money); &#125;&#125; 8、创建applicationContext.xml 先不加入事务处理 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;&lt;!-- 注解扫描 --&gt;&lt;context:component-scan base-package=&quot;name.yaohuan.spring.dao&quot;&gt;&lt;/context:component-scan&gt;&lt;context:component-scan base-package=&quot;name.yaohuan.spring.service&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 指定spring读取db.properties配置 --&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;&lt;!-- 1、连接池 --&gt;&lt;bean name=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; &gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2、JdbcTemplate --&gt;&lt;bean name=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; &gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; 9、创建测试 123456789101112package name.yaohuan.spring.service;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class TxTest &#123; @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void testTransfer()&#123; accountService.transfer(1, 2, 100d); &#125;&#125; 二十、复习事务相关概念一、什么是事务(Transaction) 是并发控制的单元，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。通过事务，sql 能将逻辑相关的一组操作绑定在一起，以便服务器 保持数据的完整性。事务通常是以begin transaction开始，以commit或rollback结束。Commint表示提交，即提交事务的所有操作。具体地说就是将事务中所有对数据的更新写回到磁盘上的物理数据库中去，事务正常结束。Rollback表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态。 设想网上购物的一次交易，其付款过程至少包括以下几步数据库操作： 1、更新客户所购商品的库存信息 2、保存客户付款信息–可能包括与银行系统的交互 3、生成订单并且保存到数据库中 4、更新用户相关信息，例如购物数量等等 正常的情况下，这些操作将顺利进行，最终交易成功，与交易相关的所有数据库信息也成功地更新。但是，如果在这一系列过程中任何一个环节出了差错，例如在更新商品库存信息时发生异常、该顾客银行帐户存款不足等，都将导致交易失败。一旦交易失败，数据库中所有信息都必须保持交易前的状态不变，比如最后一步更新用户信息时失败而导致交易失败，那么必须保证这笔失败的交易不影响数据库的状态–库存信息没有被更新、用户也没有付款，订单也没有生成。否则，数据库的信息将会一片混乱而不可预测。 数据库事务正是用来保证这种情况下交易的平稳性和可预测性的技术 二、为什么要使用事务？ 1、为了提高性能 2、为了保持业务流程的完整性 3、使用分布式事务 三、事务的特性 ACID 1、原子性（atomicity） 事务是数据库的逻辑工作单位，而且是必须是原子工作单位，对于其数据修改，要么全部执行，要么全部不执行。 2、一致性（consistency） 事务在完成时，必须是所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。 3、隔离性（isolation） 一个事务的执行不能被其他事务所影响。企业级的数据库每一秒钟都可能应付成千上万的并发访问，因而带来了并发控制的问题。由数据库理论可知，由于并发访问，在不可预料的时刻可能引发如下几个可以预料的问题：（见“二、事务的并发问题“） 4、持久性（durability） 一个事务一旦提交，事物的操作便永久性的保存在DB中。即使此时再执行回滚操作也不能撤消所做的更改 四、事务的并发问题 1、脏读（Dirty Read） 一个事务读取到了另一个事务未提交的数据操作结果。这是相当危险的，因为很可能所有的操作都被回滚。 2、不可重复读（虚读）（NonRepeatable Read） 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。 3、幻读（Phantom Read） 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据，这是因为在两次查询过程中有另外一个事务插入数据造成的 五、事务的隔离级别 1 - 读未提交 Read uncommitted：最低级别，以上情况均无法保证。 2 - 读已提交 Read committed：可避免脏读情况发生。（Oracle默认） 4 - 可重复读 Repeatable read：可避免脏读、不可重复读情况的发生。不可以避免虚读。（MySQl默认） 8 - 串行化读Serializable：事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重。 二十一、spring的事务管理接口1、Spring 的 TransactionManager 接口： 在不同平台，操作事务的代码各不相同，因此spring提供了一个 TransactionManager 接口： DateSourceTransactionManager 用于 JDBC 的事务管理 HibernateTransactionManager 用于 Hibernate 的事务管理 JpaTransactionManager 用于 Jpa 的事务管理 2、Spring中 TransactionManager 接口的定义（源码） 事务的属性介绍：这里定义了传播行为、隔离级别、超时时间、是否只读 绝大部分场景下会使用 PROPAGATION_REQUIRED 和 PROPAGATION_SUPPORTS 12345678910111213141516171819202122232425262728package org.springframework.transaction;public interface TransactionDefinition &#123; int PROPAGATION_REQUIRED = 0; //支持当前事务，如果不存在，就新建一个 int PROPAGATION_SUPPORTS = 1; //支持当前事务，如果不存在，就不使用事务 int PROPAGATION_MANDATORY = 2; //支持当前事务，如果不存在，就抛出异常 int PROPAGATION_REQUIRES_NEW = 3;//如果有事务存在，挂起当前事务，创建一个新的事物 int PROPAGATION_NOT_SUPPORTED = 4;//以非事务方式运行，如果有事务存在，挂起当前事务 int PROPAGATION_NEVER = 5;//以非事务方式运行，如果有事务存在，就抛出异常 int PROPAGATION_NESTED = 6;//如果有事务存在，则嵌套事务执行 int ISOLATION_DEFAULT = -1;//默认级别，MYSQL: 默认为REPEATABLE_READ级别 SQLSERVER: 默认为READ_COMMITTED int ISOLATION_READ_UNCOMMITTED = 1;//读取未提交数据(会出现脏读, 不可重复读) 基本不使用 int ISOLATION_READ_COMMITTED = 2;//读取已提交数据(会出现不可重复读和幻读) int ISOLATION_REPEATABLE_READ = 4;//可重复读(会出现幻读) int ISOLATION_SERIALIZABLE = 8;//串行化 int TIMEOUT_DEFAULT = -1;//默认是-1，不超时，单位是秒 //事务的传播行为 int getPropagationBehavior(); //事务的隔离级别 int getIsolationLevel(); //事务超时时间 int getTimeout(); //是否只读 boolean isReadOnly(); String getName();&#125; 二十二、xml事务管理1、在applicationContext.xml中添加 tx 名称空间 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;&lt;/beans&gt; 2、在applicationContext.xml中添加事务相关配置 12345678910111213141516171819202122232425262728293031&lt;!-- 事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 通知 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;!-- REQUIRED：如果有事务，则在事务中执行；如果没有事务，则开启一个新的事物 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;!-- SUPPORTS：如果有事务，则在事务中执行；如果没有事务，则不会开启事物 --&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 切面 --&gt;&lt;aop:config&gt; &lt;!-- 定义在service包或者子包里的任意方法的执行 --&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* name.yaohuan.spring.service..*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot; /&gt;&lt;/aop:config&gt; 自定义aop和spring事物的执行顺序分析 1、如果先配置spring的事物，后配置自定义的aop，那么事物会在自定义aop通知后提交 2、如果后配置spring的事物，先配置自定义的aop，那么事物会在自定义aop通知前提交 二十三、注解事务管理1、修改 applicationContext.xml 在 applicationContext.xml 中添加开启注解事务的配置，删除通知和切面的配置，保留事务管理器的配置 12345678&lt;!-- 事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 开启使用注解管理aop事务 --&gt;&lt;tx:annotation-driven/&gt; 2、在service层的每个方法上添加事务的配置 123@Override @Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false) public void transfer(final Integer from,final Integer to,final Double money) &#123; 也可以在类名上方定义 @Transactional 或配置通用属性，统一定义所有的service方法。如果有方法采用不同的配置，则在方法名上方单独配置","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zymmx.github.io/tags/Spring/"}]},{"title":"hexo + github 搭建个人博客","slug":"hexo + github 搭建个人博客","date":"2018-11-21T17:59:15.656Z","updated":"2018-11-21T17:58:46.722Z","comments":true,"path":"2018/11/22/hexo + github 搭建个人博客/","link":"","permalink":"https://zymmx.github.io/2018/11/22/hexo + github 搭建个人博客/","excerpt":"","text":"hexo + github 搭建个人博客（基础篇）前言：电脑系统为window 10专业版，64位 相关步骤： 1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 原文链接地址：https://www.cnblogs.com/fengxiongZz/p/7707219.html 添加 关于页面使用：hexo new page “about” 新建一个 关于我 页面。主题的 _config.yml 文件中的 menu 中进行匹配 menu: home: / //主页 categories: /categories //分类 archives: /archives //归档 tags: /tags //标签 about: /about //关于 （添加此行即可）编辑 about 关于页面 md文件 部署就能看到 进阶链接：http://www.cnblogs.com/fengxiongZz/p/7707568.html 主题链接：https://hexo.io/themes/ 配置文件按需安装 常用命令： 提交 ：commit 更新：cd themes/shana ​ git pull origin master 部署：hexo d -g","categories":[{"name":"杂散","slug":"杂散","permalink":"https://zymmx.github.io/categories/杂散/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zymmx.github.io/tags/hexo/"}]},{"title":"Node.js安装及环境变量配置","slug":"Node.js安装及环境变量配置","date":"2018-11-21T15:39:18.386Z","updated":"2018-11-21T17:54:54.652Z","comments":true,"path":"2018/11/21/Node.js安装及环境变量配置/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Node.js安装及环境变量配置/","excerpt":"","text":"Node.js安装及环境变量配置傻瓜式安装，注意选择保存的路径 此处说明下：新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。 例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【D:\\Develop\\nodejs】下创建两个文件夹【node_global】及【node_cache】如下图： 创建完两个空文件夹之后，打开cmd命令窗口，输入 12npm config set prefix &quot;D:\\Develop\\nodejs\\node_global&quot;npm config set cache &quot;D:\\Develop\\nodejs\\node_cache&quot; 接下来，关闭命令窗口 进入环境变量对话框，在【系统变量】下新建【NODE_PATH】，输入【D:\\Develop\\nodejs\\node_global\\node_modules】，将【用户变量】下的【Path】修改为【D:\\Develop\\nodejs\\node_global】 npm config set prefix “E:\\Nodejs\\node_global” npm config set cache “E:\\Nodejs\\node_cache” C:\\Users\\Administrator\\AppData\\Roaming\\npm 配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，输入如下命令进行模块的全局安装： 1npm install express -g # -g是全局安装的意思","categories":[{"name":"杂散","slug":"杂散","permalink":"https://zymmx.github.io/categories/杂散/"}],"tags":[{"name":"js","slug":"js","permalink":"https://zymmx.github.io/tags/js/"}]},{"title":"虚拟机安装及相关环境配置","slug":"虚拟机安装及相关环境配置","date":"2018-11-21T09:56:42.084Z","updated":"2018-07-14T06:13:48.934Z","comments":true,"path":"2018/11/21/虚拟机安装及相关环境配置/","link":"","permalink":"https://zymmx.github.io/2018/11/21/虚拟机安装及相关环境配置/","excerpt":"","text":"虚拟机安装及相关环境配置一：虚拟机安装123456789101112131415161718192021222324252627傻瓜式安装注意断开可移动设备中的cd/dvdsu root命令是切换到root用户passwd 空格 回车是修改密码如果是ssh访问的是别的电脑上的虚拟机，需要将虚拟机的网络设置成桥接ervice sshd status命令查看sshd服务的运行状态如果状态不是running使用命令启动service sshd start使用工具进行远程连接时，需要开放22端口使用iptables开放如下端口（如下开放22端口，其他类似）/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT保存/etc/rc.d/init.d/iptables save重启服务service iptables restart如果配置不成功，或者不想这么麻烦每个端口都配置，可以关闭防火墙关闭防火墙：service iptables stop 二：mysql安装12345678910111213141516171819202122232425262728293031323334351.使用工具（xftp），将压缩包上传到usr/local/software下【usr/local无读写权限限制，software如没有可新建】2.解压，并重命名为mysqlcd /usr/local/softwaretar -zxvf mysql-5.6.38-linux-glibc2.12-x86_64.tar.gz3.cd mysql进入解压后的目录执行下面的命令安装mysql:scripts/mysql_install_db --user=mysql --basedir=/usr/local/software/mysql --datadir=/usr/local/software/mysql/data4.执行vim my.cnf 编辑mysql配置文件，添加如下两行内容：basedir=/usr/local/software/mysqldatadir=/usr/local/software/mysql/data5.执行vim /etc/my.cnf编辑文件，加入两行：basedir=/usr/local/software/mysqldatadir=/usr/local/software/mysql/data6.执行命令cp support-files/mysql.server /etc/init.d/mysql，把启动脚本放到开机初始化目录启动mysql服务：执行命令service mysql start执行命令：ps -ef|grep mysql 看到mysql服务说明启动成功7.输入mysql 回车set password for root@localhost = password(&apos;root&apos;);修改root的密码退出输入quit8.再登录的时候报错：使用mysql –u 用户名 –p登录执行下面的命令，让root可以远程登录：grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;9.linux下的mysql默认是大小写敏感的，通过java操作数据库的时候会出现找不到表的情况，需要设置大小写不敏感vim /etc/my.cnf[mysqld]后添加添加lower_case_table_names=1 三：jdk安装12345678910111213141516171819202122CentOS一般会自带两个jdk，使用命令查看：rpm -qa | grep javarpm -e --nodeps 要卸载的包 (包通过上面的指令可以获取到)]如：rpm -e --nodeps java-1.7.0-openjdk-1.7.0.99-2.6.5.1.el6.x86_64rpm -e --nodeps java-1.6.0-openjdk-1.6.0.38-1.13.10.4.el6.x86_64将下载好的安装包上传到linux的/usr/local/software目录下执行tar -zxvf jdk-8u151-linux-x64.tar.gz命令解压文件配置环境变量vim /etc/profile在文件最末尾加上下面几句话：export JAVA_HOME=/usr/local/software/jdk1.8.0_151export JRE_HOME=/usr/local/software/jdk1.8.0_151/jreexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin保存退出让配置生效：source /etc/profile检查环境：运行java –version能看到版本信息 四：tomcat安装1234567891011121314151617181920同上，上传并解压下载的tomcat进入tomcat解压路径的bin 目录运行 sh startup.sh启动tomcat浏览器里输入 服务器ip:8080能看到欢迎界面可以将tomcat安装成系统服务复制tomcat安装路径下的bin/catalina.sh作为系统服务脚本cp /usr/local/software/apache-tomcat-8.5.23/bin/catalina.sh /etc/init.d/tomcat #重命名的tomcat为以后的服务名修改复制后的文件vim /etc/init.d/tomcat在文件比较靠前的位置，把jdk的安装路经和tomcat的安装路径设置进去# os specific support --------JAVA_HOME=/usr/local/software/jdk1.8.0_151CATALINA_HOME=/usr/local/software/apache-tomcat-8.5.23保存并退出，可以通过service tomcat stop或start来停止或启动tomcat","categories":[{"name":"linux","slug":"linux","permalink":"https://zymmx.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zymmx.github.io/tags/linux/"}]},{"title":"AngularJS入门","slug":"AngularJS","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-14T06:12:41.917Z","comments":true,"path":"2018/11/21/AngularJS/","link":"","permalink":"https://zymmx.github.io/2018/11/21/AngularJS/","excerpt":"","text":"AngularJS四大特征MVC: Model:数据,其实就是angular变量($scope.XX); View: 数据的呈现,Html+Directive(指令); Controller:操作数据,就是function,数据的增删改查; 双向绑定：声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS使得对DOM的操作不再重要并提升了可测试性。 依赖注入：依赖注入(Dependency Injection,简称DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的service和provider两类对象，都可以根据形参名称实现DI. 模块化设计：高内聚低耦合法则 （官方提供的模块（ng等），自定义模块） 指令及入门demong-app指令:告诉子元素一下的指令是归angularJs的,angularJs会识别的 ;定义了 AngularJS 应用程序的 根元素 ;在网页加载完毕时会自动引导（自动初始化）应用程序。 123456789101112demo01:双向绑定&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-1 双向绑定&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;&#123;&#123;myname&#125;&#125;,你好&lt;/body&gt;&lt;/html&gt; ng-model指令：用于绑定变量,这样用户在文本框输入的内容会绑定到变量上，而表达式可以实时地输出变量。 ng-init指令来对变量初始化 123456789101112demo02用ng-init指令来对变量初始化&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-2 初始化&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app ng-init=&quot;myname=&apos;陈大海&apos;&quot;&gt;请输入你的姓名：&lt;input ng-model=&quot;myname&quot;&gt;&lt;br&gt;&#123;&#123;myname&#125;&#125;,你好&lt;/body&gt;&lt;/html&gt; ng-controller：用于指定所使用的控制器。 123456789101112131415161718192021222324demo03控制器指令的使用&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-3 事件指令&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.add=function()&#123; $scope.z= parseInt($scope.x)+parseInt($scope.y); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;x:&lt;input ng-model=&quot;x&quot; &gt;y:&lt;input ng-model=&quot;y&quot; &gt;&lt;button ng-click=&quot;add()&quot;&gt;运算&lt;/button&gt;结果：&#123;&#123;z&#125;&#125;&lt;/body&gt;&lt;/html&gt;$scope 的使用贯穿整个 AngularJS App 应用,它与数据模型相关联,同时也是表达式执行的上下文.有了$scope 就在视图和控制器之间建立了一个通道,基于作用域视图在修改数据时会立刻更新 $scope,同样的$scope 发生改变时也会立刻重新渲染视图. ng-repeat指令：用于循环数组变量 123456789101112131415161718192021demo04:ng-repeat=&quot;x in list&quot;数组的值传入x中&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-4 循环数据&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.list= [100,192,203,434 ];//定义数组 &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr ng-repeat=&quot;x in list&quot;&gt; &lt;td&gt;&#123;&#123;x&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132demo05:循环对象数组&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-5 循环对象数组&lt;/title&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope)&#123; $scope.list= [ &#123;name:&apos;张三&apos;,shuxue:100,yuwen:93&#125;, &#123;name:&apos;李四&apos;,shuxue:88,yuwen:87&#125;, &#123;name:&apos;王五&apos;,shuxue:77,yuwen:56&#125; ];//定义数组 &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.shuxue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.yuwen&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; $http ：内置服务，从后端获取数据 1234567891011121314151617181920212223242526272829303132333435demo05:内置服务&lt;html&gt;&lt;head&gt; &lt;title&gt;入门小Demo-8 内置服务&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app=angular.module(&apos;myApp&apos;,[]); //定义了一个叫myApp的模块 //定义控制器 app.controller(&apos;myController&apos;,function($scope,$http)&#123; $scope.findAll=function()&#123; $http.get(&apos;../后台传来的json数据地址&apos;).success( function(response)&#123; $scope.list=response; &#125; ); &#125; &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myController&quot; ng-init=&quot;findAll()&quot;&gt;&lt;table&gt;&lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr ng-repeat=&quot;entity in list&quot;&gt; &lt;td&gt;&#123;&#123;entity.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.shuxue&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;entity.yuwen&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"框架","slug":"框架","permalink":"https://zymmx.github.io/categories/框架/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zymmx.github.io/tags/web/"}]},{"title":"Dubbox+Zookeeper入门","slug":"Dubbox","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-14T06:05:25.255Z","comments":true,"path":"2018/11/21/Dubbox/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Dubbox/","excerpt":"","text":"DubboxDubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在Dubbo基础上进行优化，并继续维护，为了与原有的Dubbo区分，故将其命名为Dubbox。 Dubbox 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbox就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbox这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。 节点角色说明：  Provider: 暴露服务的服务提供方。  Consumer: 调用远程服务的服务消费方。  Registry: 服务注册与发现的注册中心。  Monitor: 统计服务的调用次调和调用时间的监控中心。  Container: 服务运行容器。 调用关系说明：  0. 服务容器负责启动，加载，运行服务提供者。  1. 服务提供者在启动时，向注册中心注册自己提供的服务。  2. 服务消费者在启动时，向注册中心订阅自己所需的服务。  3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推 送变更数据给消费者。  4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用， 如果调用失败，再选另一台调用。  5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计 数据到监控中心 注册中心Zookeeper官方推荐使用 zookeeper 注册中心。注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 Zookeeper 是Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbox 服务的注册中心，工业强度较高，可用于生产环境。 Zookeeper 在Linux系统的安装1：安装jdk 2：上传安装包：Alt+P 进入SFTP ，输入put d:\\zookeeper-3.4.6.tar.gz 上传 ；也可以直接用工具拖动上传 3： 解压：tar -zxvf zookeeper-3.4.6.tar.gz 4： 进入 zookeeper-3.4.6 目录，创建 data 文件夹 ：mkdir data 5： 进入conf目录 ，把 zoo_sample.cfg 改名为 zoo.cfg ： ​ cd conf ​ mv zoo_sample.cfg zoo.cfg 6： 打开zoo.cfg , 修改 data 属性：dataDir=/root/zookeeper-3.4.6/data （安装路径） 7： 启动：进入bin里，执行启动程序 ：./zkServer.sh start Dubbox本地 JAR包部署与安装Dubbox的jar包并没有部署到Maven的中央仓库中，大家在Maven的中央仓库中可以查找到Dubbo的最终版本是2.5.3 , 阿里巴巴解散了Dubbo团队后由当当网继续维护此项目，并改名为 Dubbox ,坐标不变，版本变更了，但是并没有提交到中央仓库。 我们现在需要手动将Dubbox的jar包安装到我的本地仓库中。 先将dubbo-2.8.4.jar包放到d:\\setup, 然后输入命令 mvn install:install-file -Dfile=d:\\setup\\dubbo-2.8.4.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=2.8.4 -Dpackaging=jar Eclipse配置离线约束 (将dubbo.xsd文件配置上：windows —-&gt;preferences—–&gt;xml catalog) http://code.alibabatech.com/schema/dubbo/dubbo.xsd 管理中心的部署我们在开发时，需要知道注册中心都注册了哪些服务，以便我们开发和测试。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 管理端安装 （1）编译源码，得到war包 我们有个dubbox-master.zip ，这个是dubbox的源码，我们可以使用maven命令编译源码得到“管理端”的war包 将此压缩包解压，在命令符下进入dubbo-admin目录 ，输入maven命令 mvn package -Dmaven.skip.test=true （2）进入target文件夹，你会看到一个dubbo-admin-2.8.4.war ， 在linux服务器上安装tomcat, 将此war包上传到linux服务器的tomcat的webapps下。为了访问方便，你可以把版本号去掉。 启动tomcat后自动解压。 （3）如果你部署在zookeeper同一台主机并且端口是默认的2181，则无需修改任何配置。如果不是在一台主机上或端口被修改，需要修改WEB-INF下的dubbo.properties ，修改如下配置： dubbo.registry.address=zookeeper://127.0.0.1:2181 （4）打开浏览器，输入http://部署的linux主机地址:8080/dubbo-admin/ ,登录用户名和密码均为root 进入首页。","categories":[{"name":"架构","slug":"架构","permalink":"https://zymmx.github.io/categories/架构/"}],"tags":[{"name":"soa","slug":"soa","permalink":"https://zymmx.github.io/tags/soa/"}]},{"title":"java基础之进程与线程","slug":"java基础之线程","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-13T13:32:30.462Z","comments":true,"path":"2018/11/21/java基础之线程/","link":"","permalink":"https://zymmx.github.io/2018/11/21/java基础之线程/","excerpt":"","text":"java基础之进程与线程进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 线程和进程各自有什么区别和优劣呢？ 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 线程必会基本线程类指的是Thread类，Runnable接口，Callable接口 一：基本方法static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程暂停执行 ，该代码放在什么位置就在什么位置昏睡 static void yield() 暂停当前正在执行的线程对象，并执行其他线程 ​ yield不一定会执行，有很多情况： ​ 1）如果所有的线程已经结束了，就剩下带有yeild方法 ​ 的线程无法谦让 ​ 2）谦让是让出时间片，不保证该线程接着又抢回来 ​ 因为该方法并不是强制性的，所以并不会抛出异常 void join() 等待该线程终止,谁调用就等待谁结束 ，地老天荒 ​ 此时的线程谦让一定成功，具有强制性 ​ 使用哪个线程对象调用就把哪个线程合并到当前线程之前执行 static Thread currentThread() 返回对当前正在执行的线程对象的引用 二：每个对象都有的方法​ wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写 ， synchronized, wait, notify 是任何对象都具有的同步工具 当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。 也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 要注意，notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑，显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while来执行，以确保条件满足和一定执行 共同点： ​ 1）都需要在synchronized代码块里面执行，否则抛出异常 ​ 2）都是Object的方法，所以所有的线程锁对象都可以使用 ​ 3）都需要先获得这把锁才可以执行 ​ 区别： ​ 1）wait方法是使得当前线程对象处于等待状态，并且主动释放对象锁 ​ 并且无法再次获得该锁 ​ 2）notify和notifyAll是使得在该锁上处于等待状态的线程恢复活性 ​ 但是不保证执行，原因是还需要获取时间片才可以，事实上唤醒 ​ 操作使得线程对象还原到Runnable状态 monitor 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667主要用法：synchronized单独使用：代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;直接用于方法： 相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125;synchronized, wait, notify结合:典型场景生产者消费者问题/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;产品已满,请稍候再生产&quot;); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println(&quot;生产者生产第&quot; + this.product + &quot;个产品.&quot;); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println(&quot;缺货,稍候再取&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println(&quot;消费者取走了第&quot; + this.product + &quot;个产品.&quot;); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; 三：死锁两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。产生四个条件： ​ 请求保持————我不会轻易放弃的，灰太狼 ​ 请求互斥————资源的拥有方本身是矛盾的 ​ 不可剥夺————不能强行剥夺其他的线程的资源 ​ 形成环路————资源本身是唯一的，不可复制 四：ThreadLocal提供一个数据存储，把这个数据共享给每个线程，每个线程都可以自由的增删改这个数据，但是最后修改都是失效的 12345678910111213141516171819202122232425262728293031323334353637383940 常用方法： protected T initialValue() 返回此线程局部变量的当前线程的“初始值” 这个方法在类外无法直接使用，匿名内部类可以解决这个问题 代码： // 构建ThreadLocal的对象，并且初始化线程本地变量 ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; //此时后面的泛型必须要写，否则报错 @Override protected Integer initialValue() &#123; return 10; &#125; &#125;;ThreadLocal多线程操作代码 public static void main(String[] args) &#123; ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 10; &#125; &#125;; Thread[] ts = new Thread[5]; for (int i = 0; i &lt; ts.length; i++) &#123; ts[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; //获取线程本地化变量的值 Integer number = threadLocal.get(); System.out.println(this+&quot; &quot;+number); //给当前线程的本地化变量赋值 threadLocal.set((int)(Math.random()*10)); System.out.println(this+&quot; &quot;+threadLocal.get()); &#125; &#125;); &#125; for (int i = 0; i &lt; ts.length; i++) &#123; ts[i].start(); &#125; //也就是说线程对ThreadLocal的修改是无效的，但是每个线程都可以获取到ThreadLocal的值 System.out.println(threadLocal.get()); &#125; 五：线程的状态New—-start()——-&gt;&gt;Runnable(可运行状态) —–获取cpu——&gt;&gt;Runing ——run()结束或异常退出—–&gt;&gt;Dead 线程在Running的过程中可能会遇到阻塞(Blocked) 调用join()和sleep()方法，sleep()时间结束或被打断，join()中断,IO完成都会回到Runnable状态，等待JVM的调度。 调用wait()，使该线程处于等待池(wait blocked pool),直到notify()/notifyAll()，线程被唤醒被放到锁定池(lock blocked pool )，释放同步锁使线程回到可运行状态（Runnable） 对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。 4.此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 六：线程池","categories":[{"name":"java基础","slug":"java基础","permalink":"https://zymmx.github.io/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://zymmx.github.io/tags/java/"}]},{"title":"Web Service工作原理及实例","slug":"Web Service工作原理及实例","date":"2018-11-21T09:56:42.069Z","updated":"2018-07-11T15:25:15.371Z","comments":true,"path":"2018/11/21/Web Service工作原理及实例/","link":"","permalink":"https://zymmx.github.io/2018/11/21/Web Service工作原理及实例/","excerpt":"","text":"Web Service工作原理及实例一、Web Service基本概念 Web Service也叫XML Web Service WebService是一种可以接收从Internet或者Intranet上的其它系统中传递过来的请求，*轻量级的独立的通讯技术*。是:通过SOAP在Web上提供的软件服务，使用WSDL文件进行说明，并通过UDDI进行注册。 XML：(Extensible Markup Language)扩展型可标记语言。面向短期的临时数据处理、面向万维网络，是Soap的基础。 Soap：(Simple Object Access Protocol)**简单对象存取协议**。是XML Web Service 的通信协议。当用户通过UDDI找到你的WSDL描述文档后，他通过可以SOAP调用你建立的Web服务中的一个或多个操作。SOAP是XML文档形式的调用方法的规范，它可以支持不同的底层接口，像HTTP(S)或者SMTP。 WSDL：(Web Services Description Language) WSDL 文件是一个 XML 文档，用于说明一组 SOAP 消息以及如何交换这些消息。大多数情况下由软件自动生成和使用。 UDDI (Universal Description, Discovery, and Integration) 是一个主要针对Web服务供应商和使用者的新项目。在用户能够调用Web服务之前，必须确定这个服务内包含哪些商务方法，找到被调用的接口定义，还要在服务端来编制软件，UDDI是一种根据描述文档来引导系统查找相应服务的机制。UDDI利用SOAP消息机制（标准的XML/HTTP）来发布，编辑，浏览以及查找注册信息。它采用XML格式来封装各种不同类型的数据，并且发送到注册中心或者由注册中心来返回需要的数据。 二、调用原理​ 实现一个完整的Web服务包括以下步骤： ◆ Web服务提供者设计实现Web服务，并将调试正确后的Web服务通过Web服务中介者发布，并在UDDI注册中心注册； （发布） ◆ Web服务请求者向Web服务中介者请求特定的服务，中介者根据请求查询UDDI注册中心，为请求者寻找满足请求的服务； （发现） ◆ Web服务中介者向Web服务请求者返回满足条件的Web服务描述信息，该描述信息用WSDL写成，各种支持Web服务的机器都能阅读；（发现） ◆ 利用从Web服务中介者返回的描述信息生成相应的SOAP消息，发送给Web服务提供者，以实现Web服务的调用；（绑定） ◆ Web服务提供者按SOAP消息执行相应的Web服务，并将服务结果返回给Web服务请求者。（绑定） 三、调用方式： Net下采用GET/POST/SOAP方式动态调用WebService的简易灵活方法(C#) webservice 的调用有3种方式 1). httpget 2). httppost 3). httpsoap soap 的优点是 可以传递结构化的 数据，而前两种不行。 btw, soap 最终也是使用 HTTP 传送 XM 四、发布WebService实例1. JAX-WS发布WebService创建web工程 创建simple包，和server、client两个子包。正常情况下server和client应该是两个项目，这里我们只是演示效果，所以简化写到一个项目中： ​ 1.1 创建服务类Server123456789101112131415161718192021222324252627282930313233package simple.server;import javax.jws.WebService;import javax.xml.ws.Endpoint;//这里要加上WebService注解@WebServicepublic class SimpleServer &#123; //要发布出去的方法 public String sayHello() &#123; return &quot;hello world&quot;; &#125; //要发布出去的方法 public String speak(@WebParam(name = &quot;word&quot;) String word) &#123; return word + &quot;:webservice&quot;; &#125; ​ //**使用main方法发布出去 public static void main(String[] args) { //**第一个参数是地址，localhost是本机， //9001是端口，端口可以是任意一个未占用的端口 //SimpleService是自己起的服务名，任意 //第二个参数是要发布的这个类的对象 Endpoint.publish(“http://localhost:9001/SimpleService&quot;, new SimpleServer()); System.out.println(“Publish Success~”);//**看到这个输出代表发布成功了 } }** 运行main方法后在浏览器中输入 http://localhost:9001/SimpleService?wsdl 可以看到服务信息： Wsdl文档从下往上读 Types - 数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统)。（入参和出参的数据类型） Message - 通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构（入参和出参）。 Operation - 对服务中所支持的操作的抽象描述，一般单个Operation描述了一个访问入口的请求/响应消息对（方法）。 PortType - 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持（服务类）。 Binding - 特定服务访问点与具体服务类的绑定（不看内容，看关系）。 Port - 定义为webservice单个服务访问点。 Service- 相关服务访问点的集合。 访问上面的schemaLocation=”http://localhost:9001/SimpleService?xsd=1&quot;网址，可以看到具体方法的描述信息 如果要使用web方式发布这个webservice，只需要写一个servlet,并在tomcat启动时就加载这个servlet，在servlet的int方法中发布webservice。 如： 12345678910111213141516171819202122232425262728293031package simple.server;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.xml.ws.Endpoint;public class PublishServlet extends HttpServlet&#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; super.init(servletConfig); //发布webservice Endpoint.publish(&quot;http://localhost:9001/SimpleService&quot;, new SimpleServer()); System.out.println(&quot;Publish Success~&quot;);//看到这个输出代表发布成功了 &#125;&#125; web.xml中配置： 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;PublishServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;simple.server.PublishServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;!--启动就加载--&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;PublishServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/publish&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 需要servlet的jar包 1234567891011&lt;!--servlet依赖jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 1.2 创建客户端使用jdk自带命令调用WebService 请求webservice会在本地生成类 wsimport 是请求webservice -encoding utf-8 指定生成的java文件编码格式为utf-8 -s 后面是文件存放的工程路径 -p 是生成的java文件存放的包名 -keep 后面接的是1.1中发布出去的服务地址 运行成功后，工程中会多出几个类： wsimport -encoding utf-8 -s E:\\IdeaCoder\\Examples\\webservice\\src\\main\\java -p onetest.client -keep http://localhost:9002/SimpleSer?wsdl 一般外部，只需跟环最后 wsimport -encoding utf-8 -s E:\\IdeaCoder\\SourceDrop\\lmh_webservice\\src\\main\\java -p outer.captcha -keep http://www.webxml.com.cn/WebServices/ValidateCodeWebService.asmx?wsdl 创建测试客户端类MySimpleClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package simple.client;import org.junit.Test;import java.io.InputStream;import java.io.OutputStream;import java.net.HttpURLConnection;import java.net.URL;public class MySimpleClient &#123; @Test public void testJdkMethod() &#123; //&lt;service name=&quot;SimpleServerService&quot;&gt; // &lt;port name=&quot;SimpleServerPort&quot; binding=&quot;tns:SimpleServerPortBinding&quot;&gt; // &lt;soap:address location=&quot;http://localhost:9001/SimpleService&quot;/&gt; // &lt;/port&gt; // &lt;/service&gt; //这个是xml文件中的service-name // &lt;service name=&quot;SimpleServerService&quot;&gt; SimpleServerService simpleServerService = new SimpleServerService(); //这个是&lt;port name=&quot;SimpleServerPort&quot; SimpleServer simpleServer = simpleServerService.getSimpleServerPort(); System.out.println(simpleServer.sayHello()); &#125; 1&#125; 通过jdk生成的SimpleServer，可以调用相应的方法，实际上返回响应的是服务器，但执行的时候就像调用自己写的类一样。可以清楚的看到方法和参数。 另一种调用的方式，直接使用java方法，不生成类： 新建一个other包，存放如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package simple.other;import javax.jws.WebMethod;import javax.jws.WebParam;import javax.jws.WebService;import javax.xml.bind.annotation.XmlSeeAlso;import javax.xml.ws.RequestWrapper;import javax.xml.ws.ResponseWrapper;//对应xml文件//&lt;definitions targetNamespace=&quot;http://server.simple/&quot; name=&quot;SimpleServerService&quot;&gt;@WebService(name = &quot;SimpleServerService&quot;, targetNamespace = &quot;http://server.simple/&quot;)@XmlSeeAlso(&#123;&#125;)public interface MySimpleClient &#123; @WebMethod @RequestWrapper(localName = &quot;sayHello&quot;) @ResponseWrapper(localName = &quot;sayHelloResponse&quot;) public String sayHello(); @WebMethod @RequestWrapper(localName = &quot;speak&quot;) @ResponseWrapper(localName = &quot;speakResponse&quot;) public String speak(@WebParam(name = &quot;word&quot;)String word);&#125; 测试代码： 123456789101112131415161718192021package simple.other;import javax.xml.namespace.QName;import javax.xml.ws.Service;import java.net.URL;public class OtherTest &#123; public static void main(String[] args) throws Exception &#123; URL wsdlUrl = new URL(&quot;http://localhost:9001/SimpleService?wsdl&quot;); // targetNamespace=&quot;http://server.simple/&quot; name=&quot;SimpleServerService&quot; Service s = Service.create(wsdlUrl, 123 new QName(&quot;http://server.simple/&quot;,&quot;SimpleServerService&quot;));MySimpleClient client = 1s.getPort( 1new QName(&quot;http://server.simple/&quot;, 1&quot;SimpleServerPort&quot;), 123456789 MySimpleClient.class); System.out.println(client.sayHello()); System.out.println(client.speak(&quot;123&quot;)); &#125;&#125; 2. cxf发布WebServiceJAX-WS是一种规范，CXF是他的实现。CXF可以不必关心服务端的实现方式。 为了简化代码，我们把服务端和客户端写在一个工程里，正常应该写在两个工程 2.1 发布服务新建web工程，导入jar包： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf.karaf&lt;/groupId&gt; &lt;artifactId&gt;apache-cxf&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志文件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; CXF发布服务需要一个接口和一个实现类： 123456789101112131415161718192021package server;import javax.jws.WebParam;import javax.jws.WebService;@WebService(name = &quot;CXF&quot;, targetNamespace = &quot;http://server.cxf/&quot;)public interface CxfServer &#123; String sayHello(); String speak(@WebParam(name = &quot;word&quot;) String world);&#125; 实现类： 12345678910111213141516171819202122232425package server;public class CxfServerImpl implements CxfServer &#123; @Override public String sayHello() &#123; return &quot;Hello CXF&quot;; &#125; @Override public String speak(String word) &#123; return word + &quot;CXF&quot;; &#125;&#125; 发布服务： 123456789101112131415161718192021222324252627282930313233343536373839package server;import org.apache.cxf.jaxws.JaxWsServerFactoryBean;public class CXFServerTest &#123; public static void main(String[] args) &#123; // 创建JaxWsServerFactoryBean对象 JaxWsServerFactoryBean serverFactoryBean = new JaxWsServerFactoryBean(); // 设置服务端地址 serverFactoryBean.setAddress(&quot;http://127.0.0.1:9999/cxf&quot;); // 设置服务接口 serverFactoryBean.setServiceClass(CxfServer.class); // 设置实现类对象 serverFactoryBean.setServiceBean(new CxfServerImpl()); // 发布服务 serverFactoryBean.create(); System.out.println(&quot;发布成功&quot;); &#125;&#125; 浏览器中访问：http://127.0.0.1:9999/cxf?wsdl 2.2 调用服务123456789101112131415package client;import org.apache.cxf.endpoint.Client;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class CxfClientTest &#123; public static void main(String[] args) throws Exception &#123; JaxWsDynamicClientFactory clientFactory = 1234567891011121314151617 JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient(&quot;http://127.0.0.1:9999/cxf?wsdl&quot;); //直接调用方法，不用关心服务端是怎么实现的 Object[] result = client.invoke(&quot;sayHello&quot;); System.out.println(result[0]); Object[] result2 = client.invoke(&quot;speak&quot;, &quot;123&quot;); System.out.println(result2[0]); &#125;&#125; 2.3 Spring与CXF集成引入spring的jar 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring-cxf.xml配置 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot;http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsdhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--发布服务implementor是接口实现类，address在访问的时候加载路径里--&gt; &lt;jaxws:endpoint id=&quot;cxfDemo&quot; implementor=&quot;server.CxfServerImpl&quot; address=&quot;/cxf&quot;/&gt;&lt;/beans&gt; web.xml中配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-cxf.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 使用spring发布的时候，在接口实现类上加上注解，保证发布出去的targetNamespace一致： 123@WebService(name = &quot;CXF&quot;, targetNamespace = &quot;http://server.cxf/&quot;)public class CxfServerImpl implements CxfServer &#123; 浏览器中访问：http://127.0.0.1:8080/services/cxf?wsdl 测试方法与2.2中相同，更换访问地址即可。","categories":[{"name":"服务","slug":"服务","permalink":"https://zymmx.github.io/categories/服务/"}],"tags":[{"name":"webservice","slug":"webservice","permalink":"https://zymmx.github.io/tags/webservice/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-21T03:29:27.140Z","updated":"2018-11-21T03:29:27.140Z","comments":true,"path":"2018/11/21/hello-world/","link":"","permalink":"https://zymmx.github.io/2018/11/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}